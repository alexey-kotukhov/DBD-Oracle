/*
 * This file was generated automatically by xsubpp version 1.9508 from the
 * contents of Oracle.xs. Do not edit this file, edit Oracle.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Oracle.xs"
#include "Oracle.h"

DBISTATE_DECLARE;

#line 15 "Oracle.c"
XS(XS_DBD__Oracle_constant); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle_constant)
{
    dXSARGS;
    dXSI32;
    if (items < 0 || items > 1)
       Perl_croak(aTHX_ "Usage: %s(name=Nullch)", GvNAME(CvGV(cv)));
    {
	char *	name;
	I32	RETVAL;
	dXSTARG;

	if (items < 1)
	    name = Nullch;
	else {
	    name = (char *)SvPV_nolen(ST(0));
	}
#line 31 "Oracle.xs"
    if (!ix) {
	if (!name) name = GvNAME(CvGV(cv));
	croak("Unknown DBD::Oracle constant '%s'", name);
    }
    else RETVAL = ix;
#line 39 "Oracle.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle_ORA_OCI); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle_ORA_OCI)
{
    dXSARGS;
    if (items != 0)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::ORA_OCI()");
    {
#line 42 "Oracle.xs"
    SV *sv = sv_newmortal();
    sv_setnv(sv, atof(ORA_OCI_VERSION));	/* 9.1! see docs */
    sv_setpv(sv, ORA_OCI_VERSION);		/* 9.10.11.12    */
    SvNOK_on(sv); /* dualvar hack */
    ST(0) = sv;
#line 58 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle_ora_env_var); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle_ora_env_var)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::ora_env_var(name)");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
#line 52 "Oracle.xs"
    char buf[1024];
    char *p = ora_env_var(name, buf, sizeof(buf)-1);
    SV *sv = sv_newmortal();
    if (p)
        sv_setpv(sv, p);
    ST(0) = sv;
#line 78 "Oracle.c"
    }
    XSRETURN(1);
}

#ifdef __CYGWIN32__
#define XSubPPtmpAAAA 1

XS(XS_DBD__Oracle_ora_cygwin_set_env); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle_ora_cygwin_set_env)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::ora_cygwin_set_env(name, value)");
    {
	char *	name = (char *)SvPV_nolen(ST(0));
	char *	value = (char *)SvPV_nolen(ST(1));
#line 65 "Oracle.xs"
    ora_cygwin_set_env(name, value);
#line 97 "Oracle.c"
    }
    XSRETURN_EMPTY;
}

#endif /* __CYGWIN32__ */

/* INCLUDE:  Including 'Oracle.xsi' from 'Oracle.xs' */

#include "Driver_xst.h"
#ifdef dbd_discon_all
#define XSubPPtmpAAAB 1

XS(XS_DBD__Oracle__dr_discon_all_); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__dr_discon_all_)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(drh)", GvNAME(CvGV(cv)));
    {
	SV *	drh = ST(0);
#line 42 "Oracle.xsi"
    D_imp_drh(drh);
    if (0) ix = ix;	/* avoid unused variable warning */
    ST(0) = dbd_discon_all(drh, imp_drh) ? &sv_yes : &sv_no;
#line 123 "Oracle.c"
    }
    XSRETURN(1);
}

#endif /* dbd_discon_all */
#ifdef dbd_dr_data_sources
#define XSubPPtmpAAAC 1

XS(XS_DBD__Oracle__dr_data_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__dr_data_sources)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::dr::data_sources(drh, attr = Nullsv)");
    SP -= items;
    {
	SV *	drh = ST(0);
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1);
	}
#line 56 "Oracle.xsi"
    {
	D_imp_drh(drh);
	AV *av = dbd_dr_data_sources(drh, imp_drh, attr);
	if (av) {
	    int i;
	    int n = AvFILL(av)+1;
	    EXTEND(sp, n);
	    for (i = 0; i < n; ++i) {
		PUSHs(AvARRAY(av)[i]);
	    }
	}
    }
#line 161 "Oracle.c"
	PUTBACK;
	return;
    }
}

#endif
XS(XS_DBD__Oracle__db__login); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db__login)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::_login(dbh, dbname, username, password, attribs=Nullsv)");
    {
	SV *	dbh = ST(0);
	char *	dbname = (char *)SvPV_nolen(ST(1));
	SV *	username = ST(2);
	SV *	password = ST(3);
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 86 "Oracle.xsi"
    {
    STRLEN lna;
    D_imp_dbh(dbh);
    char *u = (SvOK(username)) ? SvPV(username,lna) : "";
    char *p = (SvOK(password)) ? SvPV(password,lna) : "";
#ifdef dbd_db_login6
    ST(0) = dbd_db_login6(dbh, imp_dbh, dbname, u, p, attribs) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_db_login( dbh, imp_dbh, dbname, u, p) ? &sv_yes : &sv_no;
#endif
    }
#line 198 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_selectall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_selectall_arrayref)
{
    dXSARGS;
    {
#line 102 "Oracle.xsi"
    SV *sth;
    SV **maxrows_svp;
    SV **tmp_svp;
    SV *attr = &PL_sv_undef;
    imp_sth_t *imp_sth;
#line 214 "Oracle.c"
#line 108 "Oracle.xsi"
    if (items > 2) {
	attr = ST(2);
	if (SvROK(attr) &&
		(DBD_ATTRIB_TRUE(attr,"Slice",5,tmp_svp) || DBD_ATTRIB_TRUE(attr,"Columns",7,tmp_svp))
	) {
	    /* fallback to perl implementation */
	    ST(0) = dbixst_bounce_method("DBD::Oracle::db::SUPER::selectall_arrayref", items);
	    XSRETURN(1);
	}
    }
    /* --- prepare --- */
    if (SvROK(ST(1))) {
	sth = ST(1);
    }
    else {
	sth = dbixst_bounce_method("prepare", 3);
	if (!SvROK(sth))
	    XSRETURN_UNDEF;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {    /* need to bind params before execute */
        if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
            XSRETURN_UNDEF;
        }
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) { /* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchall --- */
    maxrows_svp = DBD_ATTRIB_GET_SVP(attr, "MaxRows", 7);
    ST(0) = dbdxst_fetchall_arrayref(sth, &PL_sv_undef, (maxrows_svp) ? *maxrows_svp : &PL_sv_undef);
#line 250 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_selectrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_selectrow_arrayref)
{
    dXSARGS;
    dXSI32;
   PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
#line 149 "Oracle.xsi"
    imp_sth_t *imp_sth;
    SV *sth;
    AV *row_av;
#line 267 "Oracle.c"
#line 153 "Oracle.xsi"
    if (SvROK(ST(1))) {
	sth = ST(1);
    }
    else {
	/* --- prepare --- */
	sth = dbixst_bounce_method("prepare", 3);
	if (!SvROK(sth))
	    XSRETURN_UNDEF;
    }
    imp_sth = (imp_sth_t*)(DBIh_COM(sth));
    /* --- bind_param --- */
    if (items > 3) {	/* need to bind params before execute */
	if (!dbdxst_bind_params(sth, imp_sth, items-2, ax+2) ) {
	    XSRETURN_UNDEF;
	}
    }
    /* --- execute --- */
    DBIc_ROW_COUNT(imp_sth) = 0;
    if ( dbd_st_execute(sth, imp_sth) <= -2 ) {	/* -2 == error */
        XSRETURN_UNDEF;
    }
    /* --- fetchrow_arrayref --- */
    row_av = dbd_st_fetch(sth, imp_sth);
    if (!row_av) {
	if (GIMME == G_SCALAR)
	    PUSHs(&PL_sv_undef);
    }
    else if (ix == 1) { /* selectrow_array */
	int i;
	int num_fields = AvFILL(row_av)+1;
	if (GIMME == G_SCALAR)
	    num_fields = 1; /* return just first field */
	EXTEND(sp, num_fields);
	for(i=0; i < num_fields; ++i) {
	    PUSHs(AvARRAY(row_av)[i]);
	}
    }
    else {
	PUSHs( sv_2mortal(newRV((SV *)row_av)) );
    }
    /* --- finish --- */
#ifdef dbd_st_finish3
    dbd_st_finish3(sth, imp_sth, 0);
#else
    dbd_st_finish(sth, imp_sth);
#endif
#line 315 "Oracle.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_db_do4 /* deebeedee-deebee-doo, deebee-doobee-dah? */
#define XSubPPtmpAAAD 1

XS(XS_DBD__Oracle__db_do); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_do)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::do(dbh, statement, params = Nullsv)");
    {
	SV *	dbh = ST(0);
	char *	statement = (char *)SvPV_nolen(ST(1));
	SV *	params;

	if (items < 3)
	    params = Nullsv;
	else {
	    params = ST(2);
	}
#line 209 "Oracle.xsi"
    {
    D_imp_dbh(dbh);
    IV retval;
    retval = dbd_db_do4(dbh, imp_dbh, statement, params);
    /* remember that dbd_db_do4 must return <= -2 for error	*/
    if (retval == 0)		/* ok with no rows affected	*/
	XST_mPV(0, "0E0");	/* (true but zero)		*/
    else if (retval < -1)	/* -1 == unknown number of rows	*/
	XST_mUNDEF(0);		/* <= -2 means error   		*/
    else
	XST_mIV(0, retval);	/* typically 1, rowcount or -1	*/
    }
#line 353 "Oracle.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_last_insert_id
#define XSubPPtmpAAAE 1

XS(XS_DBD__Oracle__db_last_insert_id); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_last_insert_id)
{
    dXSARGS;
    if (items < 5 || items > 6)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::last_insert_id(dbh, catalog, schema, table, field, attr=Nullsv)");
    {
	SV *	dbh = ST(0);
	SV *	catalog = ST(1);
	SV *	schema = ST(2);
	SV *	table = ST(3);
	SV *	field = ST(4);
	SV *	attr;

	if (items < 6)
	    attr = Nullsv;
	else {
	    attr = ST(5);
	}
#line 236 "Oracle.xsi"
    {
    D_imp_dbh(dbh);
    ST(0) = dbd_db_last_insert_id(dbh, imp_dbh, catalog, schema, table, field, attr);
    }
#line 386 "Oracle.c"
    }
    XSRETURN(1);
}

#endif
XS(XS_DBD__Oracle__db_commit); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_commit)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::commit(dbh)");
    {
	SV *	dbh = ST(0);
#line 248 "Oracle.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
	warn("commit ineffective with AutoCommit enabled");
    ST(0) = dbd_db_commit(dbh, imp_dbh) ? &sv_yes : &sv_no;
#line 405 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_rollback); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_rollback)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::rollback(dbh)");
    {
	SV *	dbh = ST(0);
#line 258 "Oracle.xsi"
    D_imp_dbh(dbh);
    if (DBIc_has(imp_dbh,DBIcf_AutoCommit) && DBIc_WARN(imp_dbh))
	warn("rollback ineffective with AutoCommit enabled");
    ST(0) = dbd_db_rollback(dbh, imp_dbh) ? &sv_yes : &sv_no;
#line 423 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_disconnect); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_disconnect)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::disconnect(dbh)");
    {
	SV *	dbh = ST(0);
#line 268 "Oracle.xsi"
    D_imp_dbh(dbh);
    if ( !DBIc_ACTIVE(imp_dbh) ) {
	XSRETURN_YES;
    }
    /* pre-disconnect checks and tidy-ups */
    if (DBIc_CACHED_KIDS(imp_dbh)) {
	SvREFCNT_dec(DBIc_CACHED_KIDS(imp_dbh));      /* cast them to the winds	*/
	DBIc_CACHED_KIDS(imp_dbh) = Nullhv;
    }
    /* Check for disconnect() being called whilst refs to cursors	*/
    /* still exists. This possibly needs some more thought.		*/
    if (DBIc_ACTIVE_KIDS(imp_dbh) && DBIc_WARN(imp_dbh) && !dirty) {
	STRLEN lna;
	char *plural = (DBIc_ACTIVE_KIDS(imp_dbh)==1) ? "" : "s";
	warn("%s->disconnect invalidates %d active statement handle%s %s",
	    SvPV(dbh,lna), (int)DBIc_ACTIVE_KIDS(imp_dbh), plural,
	    "(either destroy statement handles or call finish on them before disconnecting)");
    }
    ST(0) = dbd_db_disconnect(dbh, imp_dbh) ? &sv_yes : &sv_no;
    DBIc_ACTIVE_off(imp_dbh);	/* ensure it's off, regardless */
#line 457 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_STORE)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::STORE(dbh, keysv, valuesv)");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 296 "Oracle.xsi"
    D_imp_dbh(dbh);
    if (SvGMAGICAL(valuesv))
	mg_get(valuesv);
    ST(0) = &sv_yes;
    if (!dbd_db_STORE_attrib(dbh, imp_dbh, keysv, valuesv))
	if (!DBIc_DBISTATE(imp_dbh)->set_attr(dbh, keysv, valuesv))
	    ST(0) = &sv_no;
#line 480 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_FETCH); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_FETCH)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::FETCH(dbh, keysv)");
    {
	SV *	dbh = ST(0);
	SV *	keysv = ST(1);
#line 310 "Oracle.xsi"
    D_imp_dbh(dbh);
    SV *valuesv = dbd_db_FETCH_attrib(dbh, imp_dbh, keysv);
    if (!valuesv)
	valuesv = DBIc_DBISTATE(imp_dbh)->get_attr(dbh, keysv);
    ST(0) = valuesv;	/* dbd_db_FETCH_attrib did sv_2mortal	*/
#line 500 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::DESTROY(dbh)");
    SP -= items;
    {
	SV *	dbh = ST(0);
#line 321 "Oracle.xsi"
    D_imp_dbh(dbh);
    ST(0) = &sv_yes;
    if (!DBIc_IMPSET(imp_dbh)) {	/* was never fully set up	*/
	STRLEN lna;
	if (DBIc_WARN(imp_dbh) && !dirty && DBIc_DBISTATE(imp_dbh)->debug >= 2)
	     PerlIO_printf(DBIc_LOGPIO(imp_dbh),
		"         DESTROY for %s ignored - handle not initialised\n",
		    SvPV(dbh,lna));
    }
    else {
	/* pre-disconnect checks and tidy-ups */
	if (DBIc_CACHED_KIDS(imp_dbh)) {
	    SvREFCNT_dec(DBIc_CACHED_KIDS(imp_dbh));  /* cast them to the winds	*/
	    DBIc_CACHED_KIDS(imp_dbh) = Nullhv;
	}
        if (DBIc_IADESTROY(imp_dbh)) {		  /* want's ineffective destroy	*/
            DBIc_ACTIVE_off(imp_dbh);
        }
	if (DBIc_ACTIVE(imp_dbh)) {
	    /* The application has not explicitly disconnected. That's bad.	*/
	    /* To ensure integrity we *must* issue a rollback. This will be	*/
	    /* harmless	if the application has issued a commit. If it hasn't	*/
	    /* then it'll ensure integrity. Consider a Ctrl-C killing perl	*/
	    /* between two statements that must be executed as a transaction.	*/
	    /* Perl will call DESTROY on the dbh and, if we don't rollback,	*/
	    /* the server may automatically commit! Bham! Corrupt database!	*/
	    if (!DBIc_has(imp_dbh,DBIcf_AutoCommit)) {
		if (DBIc_WARN(imp_dbh)
		&&  DBIc_is(imp_dbh, DBIcf_Executed)
		&& (!dirty || DBIc_DBISTATE(imp_dbh)->debug >= 3)
		)
		     warn("Issuing rollback() for database handle being DESTROY'd without explicit disconnect()");
		dbd_db_rollback(dbh, imp_dbh);			/* ROLLBACK! */
	    }
	    dbd_db_disconnect(dbh, imp_dbh);
	    DBIc_ACTIVE_off(imp_dbh);	/* ensure it's off, regardless */
	}
	dbd_db_destroy(dbh, imp_dbh);
    }
#line 554 "Oracle.c"
	PUTBACK;
	return;
    }
}

#ifdef dbd_take_imp_data
#define XSubPPtmpAAAF 1

XS(XS_DBD__Oracle__db_take_imp_data); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_take_imp_data)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::take_imp_data(h)");
    {
	SV *	h = ST(0);
#line 368 "Oracle.xsi"
    D_imp_xxh(h);
    ST(0) = (dbd_take_imp_data(h, imp_xxh, NULL))
	? dbixst_bounce_method("DBD::Oracle::db::SUPER::take_imp_data", items)
	: &sv_undef;
#line 576 "Oracle.c"
    }
    XSRETURN(1);
}

#endif
#ifdef dbd_db_data_sources
#define XSubPPtmpAAAG 1

XS(XS_DBD__Oracle__db_data_sources); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_data_sources)
{
    dXSARGS;
    if (items < 1 || items > 2)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::data_sources(dbh, attr = Nullsv)");
    SP -= items;
    {
	SV *	dbh = ST(0);
	SV *	attr;

	if (items < 2)
	    attr = Nullsv;
	else {
	    attr = ST(1);
	}
#line 382 "Oracle.xsi"
    {
	D_imp_dbh(dbh);
	AV *av = dbd_db_data_sources(dbh, imp_dbh, attr);
	if (av) {
	    int i;
	    int n = AvFILL(av)+1;
	    EXTEND(sp, n);
	    for (i = 0; i < n; ++i) {
		PUSHs(AvARRAY(av)[i]);
	    }
	}
    }
#line 614 "Oracle.c"
	PUTBACK;
	return;
    }
}

#endif
XS(XS_DBD__Oracle__st__prepare); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st__prepare)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::_prepare(sth, statement, attribs=Nullsv)");
    {
	SV *	sth = ST(0);
	char *	statement = (char *)SvPV_nolen(ST(1));
	SV *	attribs;

	if (items < 3)
	    attribs = Nullsv;
	else {
	    attribs = ST(2);
	}
#line 411 "Oracle.xsi"
    {
    D_imp_sth(sth);
    DBD_ATTRIBS_CHECK("_prepare", sth, attribs);
    ST(0) = dbd_st_prepare(sth, imp_sth, statement, attribs) ? &sv_yes : &sv_no;
    }
#line 643 "Oracle.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_rows
#define XSubPPtmpAAAH 1

XS(XS_DBD__Oracle__st_rows); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_rows)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::rows(sth)");
    {
	SV *	sth = ST(0);
#line 424 "Oracle.xsi"
    D_imp_sth(sth);
    XST_mIV(0, dbd_st_rows(sth, imp_sth));
#line 662 "Oracle.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_rows */
#ifdef dbd_st_bind_col
#define XSubPPtmpAAAI 1

XS(XS_DBD__Oracle__st_bind_col); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_bind_col)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::bind_col(sth, col, ref, attribs=Nullsv)");
    {
	SV *	sth = ST(0);
	SV *	col = ST(1);
	SV *	ref = ST(2);
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3);
	}
#line 439 "Oracle.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(ref))
	mg_get(ref);
    if (attribs) {
	if (SvNIOK(attribs)) {
	    sql_type = SvIV(attribs);
	    attribs = Nullsv;
	}
	else {
	    SV **svp;
	    DBD_ATTRIBS_CHECK("bind_col", sth, attribs);
	    /* XXX we should perhaps complain if TYPE is not SvNIOK */
	    DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
	}
    }
    switch(dbd_st_bind_col(sth, imp_sth, col, ref, sql_type, attribs)) {
    case 2:	ST(0) = &sv_yes;	/* job done completely */
		break;
    case 1:	/* fallback to DBI default */
		ST(0) = (DBIc_DBISTATE(imp_sth)->bind_col(sth, col, ref, attribs))
		    ? &sv_yes : &sv_no;
		break;
    default:	ST(0) = &sv_no;		/* dbd_st_bind_col has called set_err */
		break;
    }
    }
#line 717 "Oracle.c"
    }
    XSRETURN(1);
}

#endif /* dbd_st_bind_col */
XS(XS_DBD__Oracle__st_bind_param); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_bind_param)
{
    dXSARGS;
    if (items < 3 || items > 4)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::bind_param(sth, param, value, attribs=Nullsv)");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value = ST(2);
	SV *	attribs;

	if (items < 4)
	    attribs = Nullsv;
	else {
	    attribs = ST(3);
	}
#line 477 "Oracle.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    if (SvGMAGICAL(value))
	mg_get(value);
    if (attribs) {
	if (SvNIOK(attribs)) {
	    sql_type = SvIV(attribs);
	    attribs = Nullsv;
	}
	else {
	    SV **svp;
	    DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
	    /* XXX we should perhaps complain if TYPE is not SvNIOK */
	    DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
	}
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, FALSE, 0)
		? &sv_yes : &sv_no;
    }
#line 761 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__st_bind_param_inout); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_bind_param_inout)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::bind_param_inout(sth, param, value_ref, maxlen, attribs=Nullsv)");
    {
	SV *	sth = ST(0);
	SV *	param = ST(1);
	SV *	value_ref = ST(2);
	IV	maxlen = (IV)SvIV(ST(3));
	SV *	attribs;

	if (items < 5)
	    attribs = Nullsv;
	else {
	    attribs = ST(4);
	}
#line 507 "Oracle.xsi"
    {
    IV sql_type = 0;
    D_imp_sth(sth);
    SV *value;
    if (!SvROK(value_ref) || SvTYPE(SvRV(value_ref)) > SVt_PVMG)
	croak("bind_param_inout needs a reference to a scalar value");
    value = SvRV(value_ref);
    if (SvREADONLY(value))
	croak("Modification of a read-only value attempted");
    if (SvGMAGICAL(value))
	mg_get(value);
    if (attribs) {
	if (SvNIOK(attribs)) {
	    sql_type = SvIV(attribs);
	    attribs = Nullsv;
	}
	else {
	    SV **svp;
	    DBD_ATTRIBS_CHECK("bind_param", sth, attribs);
	    DBD_ATTRIB_GET_IV(attribs, "TYPE",4, svp, sql_type);
	}
    }
    ST(0) = dbd_bind_ph(sth, imp_sth, param, value, sql_type, attribs, TRUE, maxlen)
		? &sv_yes : &sv_no;
    }
#line 810 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__st_execute); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_execute)
{
    dXSARGS;
    if (items < 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::execute(sth, ...)");
    {
	SV *	sth = ST(0);
#line 538 "Oracle.xsi"
    D_imp_sth(sth);
    int retval;
    if (items > 1) {	/* need to bind params */
	if (!dbdxst_bind_params(sth, imp_sth, items, ax) ) {
	    XSRETURN_UNDEF;
	}
    }
    /* XXX this code is duplicated in selectrow_arrayref above	*/
    if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
	DBIc_ROW_COUNT(imp_sth) = 0;
    retval = dbd_st_execute(sth, imp_sth);
    /* remember that dbd_st_execute must return <= -2 for error	*/
    if (retval == 0)		/* ok with no rows affected	*/
	XST_mPV(0, "0E0");	/* (true but zero)		*/
    else if (retval < -1)	/* -1 == unknown number of rows	*/
	XST_mUNDEF(0);		/* <= -2 means error   		*/
    else
	XST_mIV(0, retval);	/* typically 1, rowcount or -1	*/
#line 842 "Oracle.c"
    }
    XSRETURN(1);
}

#ifdef dbd_st_execute_for_fetch
#define XSubPPtmpAAAJ 1

XS(XS_DBD__Oracle__st_execute_for_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_execute_for_fetch)
{
    dXSARGS;
    if (items < 2 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::execute_for_fetch(sth, fetch_tuple_sub, tuple_status = Nullsv)");
    {
	SV *	sth = ST(0);
	SV *	fetch_tuple_sub = ST(1);
	SV *	tuple_status;

	if (items < 3)
	    tuple_status = Nullsv;
	else {
	    tuple_status = ST(2);
	}
#line 566 "Oracle.xsi"
    {
    D_imp_sth(sth);
    ST(0) = dbd_st_execute_for_fetch(sth, imp_sth, fetch_tuple_sub, tuple_status);
    }
#line 871 "Oracle.c"
    }
    XSRETURN(1);
}

#endif
XS(XS_DBD__Oracle__st_fetchrow_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_fetchrow_arrayref)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(sth)", GvNAME(CvGV(cv)));
    {
	SV *	sth = ST(0);
#line 581 "Oracle.xsi"
    D_imp_sth(sth);
    AV *av;
    if (0) ix = ix;	/* avoid unused variable warning */
    av = dbd_st_fetch(sth, imp_sth);
    ST(0) = (av) ? sv_2mortal(newRV((SV *)av)) : &PL_sv_undef;
#line 892 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__st_fetchrow_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_fetchrow_array)
{
    dXSARGS;
    dXSI32;
    if (items != 1)
       Perl_croak(aTHX_ "Usage: %s(sth)", GvNAME(CvGV(cv)));
    SP -= items;
    {
	SV *	sth = ST(0);
#line 594 "Oracle.xsi"
    D_imp_sth(sth);
    AV *av;
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
	int i;
	int num_fields = AvFILL(av)+1;
	EXTEND(sp, num_fields);
	for(i=0; i < num_fields; ++i) {
	    PUSHs(AvARRAY(av)[i]);
	}
	if (0) ix = ix;	/* avoid unused variable warning */
    }
#line 920 "Oracle.c"
	PUTBACK;
	return;
    }
}

XS(XS_DBD__Oracle__st_fetchall_arrayref); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_fetchall_arrayref)
{
    dXSARGS;
    if (items < 1 || items > 3)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::fetchall_arrayref(sth, slice=&PL_sv_undef, batch_row_count=&PL_sv_undef)");
    {
	SV *	sth = ST(0);
	SV *	slice;
	SV *	batch_row_count;

	if (items < 2)
	    slice = &PL_sv_undef;
	else {
	    slice = ST(1);
	}

	if (items < 3)
	    batch_row_count = &PL_sv_undef;
	else {
	    batch_row_count = ST(2);
	}
#line 614 "Oracle.xsi"
    if (SvOK(slice)) {  /* fallback to perl implementation */
        ST(0) = dbixst_bounce_method("DBD::Oracle::st::SUPER::fetchall_arrayref", 3);
    }
    else {
	ST(0) = dbdxst_fetchall_arrayref(sth, slice, batch_row_count);
    }
#line 955 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__st_finish); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_finish)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::finish(sth)");
    {
	SV *	sth = ST(0);
#line 626 "Oracle.xsi"
    D_imp_sth(sth);
    D_imp_dbh_from_sth;
    if (!DBIc_ACTIVE(imp_sth)) {
	/* No active statement to finish	*/
	XSRETURN_YES;
    }
    if (!DBIc_ACTIVE(imp_dbh)) {
	/* Either an explicit disconnect() or global destruction	*/
	/* has disconnected us from the database. Finish is meaningless	*/
	DBIc_ACTIVE_off(imp_sth);
	XSRETURN_YES;
    }
#ifdef dbd_st_finish3
    ST(0) = dbd_st_finish3(sth, imp_sth, 0) ? &sv_yes : &sv_no;
#else
    ST(0) = dbd_st_finish(sth, imp_sth) ? &sv_yes : &sv_no;
#endif
#line 986 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__st_blob_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_blob_read)
{
    dXSARGS;
    if (items < 4 || items > 6)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::blob_read(sth, field, offset, len, destrv=Nullsv, destoffset=0)");
    {
	SV *	sth = ST(0);
	int	field = (int)SvIV(ST(1));
	long	offset = (long)SvIV(ST(2));
	long	len = (long)SvIV(ST(3));
	SV *	destrv;
	long	destoffset;

	if (items < 5)
	    destrv = Nullsv;
	else {
	    destrv = ST(4);
	}

	if (items < 6)
	    destoffset = 0;
	else {
	    destoffset = (long)SvIV(ST(5));
	}
#line 654 "Oracle.xsi"
    {
    D_imp_sth(sth);
    if (!destrv)
        destrv = sv_2mortal(newRV(sv_2mortal(newSV(0))));
    if (dbd_st_blob_read(sth, imp_sth, field, offset, len, destrv, destoffset))
         ST(0) = SvRV(destrv);
    else ST(0) = &PL_sv_undef;
    }
#line 1025 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__st_STORE); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_STORE)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::STORE(sth, keysv, valuesv)");
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
	SV *	valuesv = ST(2);
#line 670 "Oracle.xsi"
    D_imp_sth(sth);
    if (SvGMAGICAL(valuesv))
	mg_get(valuesv);
    ST(0) = &sv_yes;
    if (!dbd_st_STORE_attrib(sth, imp_sth, keysv, valuesv))
	if (!DBIc_DBISTATE(imp_sth)->set_attr(sth, keysv, valuesv))
	    ST(0) = &sv_no;
#line 1048 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__st_FETCH_attrib); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_FETCH_attrib)
{
    dXSARGS;
    dXSI32;
    if (items != 2)
       Perl_croak(aTHX_ "Usage: %s(sth, keysv)", GvNAME(CvGV(cv)));
    {
	SV *	sth = ST(0);
	SV *	keysv = ST(1);
#line 687 "Oracle.xsi"
    D_imp_sth(sth);
    SV *valuesv;
    if (0) ix = ix;	/* avoid unused variable warning */
    valuesv = dbd_st_FETCH_attrib(sth, imp_sth, keysv);
    if (!valuesv)
	valuesv = DBIc_DBISTATE(imp_sth)->get_attr(sth, keysv);
    ST(0) = valuesv;	/* dbd_st_FETCH_attrib did sv_2mortal	*/
#line 1071 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__st_DESTROY); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_DESTROY)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::DESTROY(sth)");
    SP -= items;
    {
	SV *	sth = ST(0);
#line 700 "Oracle.xsi"
    D_imp_sth(sth);
    ST(0) = &sv_yes;
    if (!DBIc_IMPSET(imp_sth)) {	/* was never fully set up	*/
	STRLEN lna;
	if (DBIc_WARN(imp_sth) && !dirty && DBIc_DBISTATE(imp_sth)->debug >= 2)
	     PerlIO_printf(DBIc_LOGPIO(imp_sth),
		"         DESTROY for %s ignored - handle not initialised\n",
		    SvPV(sth,lna));
    }
    else {
        if (DBIc_IADESTROY(imp_sth)) { /* want's ineffective destroy    */
            DBIc_ACTIVE_off(imp_sth);
        }
	if (DBIc_ACTIVE(imp_sth)) {
	    D_imp_dbh_from_sth;
	    if (!dirty && DBIc_ACTIVE(imp_dbh)) {
#ifdef dbd_st_finish3
		dbd_st_finish3(sth, imp_sth, 1);
#else
		dbd_st_finish(sth, imp_sth);
#endif
	    }
	    else {
		DBIc_ACTIVE_off(imp_sth);
	    }
	}
	dbd_st_destroy(sth, imp_sth);
    }
#line 1114 "Oracle.c"
	PUTBACK;
	return;
    }
}


/* INCLUDE: Returning to 'Oracle.xs' from 'Oracle.xsi' */

XS(XS_DBD__Oracle__st_ora_fetch); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_ora_fetch)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::ora_fetch(sth)");
    SP -= items;
    {
	SV *	sth = ST(0);
#line 78 "Oracle.xs"
    /* fetchrow: but with scalar fetch returning NUM_FIELDS for Oraperl	*/
    /* This code is called _directly_ by Oraperl.pm bypassing the DBI.	*/
    /* as a result we have to do some things ourselves (like calling	*/
    /* CLEAR_ERROR) and we loose the tracing that the DBI offers :-(	*/
    D_imp_sth(sth);
    AV *av;
    int debug = DBIc_DEBUGIV(imp_sth);
    if (DBIS->debug > debug)
	debug = DBIS->debug;
    DBIh_CLEAR_ERROR(imp_sth);
    if (GIMME == G_SCALAR) {	/* XXX Oraperl	*/
	/* This non-standard behaviour added only to increase the	*/
	/* performance of the oraperl emulation layer (Oraperl.pm)	*/
	if (!imp_sth->done_desc && !dbd_describe(sth, imp_sth))
		XSRETURN_UNDEF;
	XSRETURN_IV(DBIc_NUM_FIELDS(imp_sth));
    }
    if (debug >= 2)
	PerlIO_printf(DBILOGFP, "    -> ora_fetch\n");
    av = dbd_st_fetch(sth, imp_sth);
    if (av) {
	int num_fields = AvFILL(av)+1;
	int i;
	EXTEND(sp, num_fields);
	for(i=0; i < num_fields; ++i) {
	    PUSHs(AvARRAY(av)[i]);
	}
	if (debug >= 2)
	    PerlIO_printf(DBILOGFP, "    <- (...) [%d items]\n", num_fields);
    }
    else {
	if (debug >= 2)
	    PerlIO_printf(DBILOGFP, "    <- () [0 items]\n");
    }
    if (debug >= 2 && SvTRUE(DBIc_ERR(imp_sth)))
	PerlIO_printf(DBILOGFP, "    !! ERROR: %s %s",
	    neatsvpv(DBIc_ERR(imp_sth),0), neatsvpv(DBIc_ERRSTR(imp_sth),0));
#line 1170 "Oracle.c"
	PUTBACK;
	return;
    }
}

XS(XS_DBD__Oracle__st_ora_execute_array); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_ora_execute_array)
{
    dXSARGS;
    if (items < 4 || items > 5)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::ora_execute_array(sth, tuples, exe_count, tuples_status, cols=&sv_undef)");
    {
	SV *	sth = ST(0);
	SV *	tuples = ST(1);
	IV	exe_count = (IV)SvIV(ST(2));
	SV *	tuples_status = ST(3);
	SV *	cols;
#line 124 "Oracle.xs"
    D_imp_sth(sth);
    int retval;
#line 1191 "Oracle.c"

	if (items < 5)
	    cols = &sv_undef;
	else {
	    cols = ST(4);
	}
#line 127 "Oracle.xs"
    /* XXX Need default bindings if any phs are so far unbound(?) */
    /* XXX this code is duplicated in selectrow_arrayref above  */
    if (DBIc_ROW_COUNT(imp_sth) > 0) /* reset for re-execute */
        DBIc_ROW_COUNT(imp_sth) = 0;
    retval = ora_st_execute_array(sth, imp_sth, tuples, tuples_status,
                                  cols, (ub4)exe_count);
    /* XXX Handle return value ... like DBI::execute_array(). */
    /* remember that dbd_st_execute must return <= -2 for error */
    if (retval == 0)            /* ok with no rows affected     */
        XST_mPV(0, "0E0");      /* (true but zero)              */
    else if (retval < -1)       /* -1 == unknown number of rows */
        XST_mUNDEF(0);          /* <= -2 means error            */
    else
        XST_mIV(0, retval);     /* typically 1, rowcount or -1  */
#line 1213 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__st_cancel); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__st_cancel)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::st::cancel(sth)");
    {
	SV *	sth = ST(0);
#line 147 "Oracle.xs"
    D_imp_sth(sth);
    ST(0) = dbd_st_cancel(sth, imp_sth) ? &sv_yes : &sv_no;
#line 1229 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_reauthenticate); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_reauthenticate)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::reauthenticate(dbh, uid, pwd)");
    {
	SV *	dbh = ST(0);
	char *	uid = (char *)SvPV_nolen(ST(1));
	char *	pwd = (char *)SvPV_nolen(ST(2));
#line 159 "Oracle.xs"
    D_imp_dbh(dbh);
    ST(0) = ora_db_reauthenticate(dbh, imp_dbh, uid, pwd) ? &sv_yes : &sv_no;
#line 1247 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_ora_lob_write); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_write)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::ora_lob_write(dbh, locator, offset, data)");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
	UV	offset = (UV)SvUV(ST(2));
	SV *	data = ST(3);
#line 169 "Oracle.xs"
    D_imp_dbh(dbh);
    ub4 amtp;
    STRLEN data_len; /* bytes not chars */
    dvoid *bufp;
    sword status;
    ub2 csid;
    ub1 csform;
#line 1271 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "locator is not of type OCILobLocatorPtr");
#line 177 "Oracle.xs"
    csid = 0;
    csform = SQLCS_IMPLICIT;
    bufp = SvPV(data, data_len);
    amtp = data_len;
    /* if locator is CLOB and data is UTF8 and not in bytes pragma */
    /* if (0 && SvUTF8(data) && !IN_BYTES) { amtp = sv_len_utf8(data); }  */
    /* added by lab: */
    /* LAB do something about length here? see above comment */
    OCILobCharSetForm_log_stat( imp_dbh->envhp, imp_dbh->errhp, locator, &csform, status );
    if (status != OCI_SUCCESS) {
        oci_error(dbh, imp_dbh->errhp, status, "OCILobCharSetForm");
	ST(0) = &sv_undef;
        return;
    }
#ifdef OCI_ATTR_CHARSET_ID
    /* Effectively only used so AL32UTF8 works properly */
    OCILobCharSetId_log_stat( imp_dbh->envhp, imp_dbh->errhp, locator, &csid, status );
    if (status != OCI_SUCCESS) {
        oci_error(dbh, imp_dbh->errhp, status, "OCILobCharSetId");
	ST(0) = &sv_undef;
        return;
    }
#endif /* OCI_ATTR_CHARSET_ID */
    /* if data is utf8 but charset isn't then switch to utf8 csid */
    csid = (SvUTF8(data) && !CS_IS_UTF8(csid)) ? utf8_csid : CSFORM_IMPLIED_CSID(csform);

    OCILobWrite_log_stat(imp_dbh->svchp, imp_dbh->errhp, locator,
	    &amtp, (ub4)offset,
	    bufp, (ub4)data_len, OCI_ONE_PIECE,
	    NULL, NULL,
	    (ub2)0, csform , status);
    if (status != OCI_SUCCESS) {
        oci_error(dbh, imp_dbh->errhp, status, "OCILobWrite");
	ST(0) = &sv_undef;
    }
    else {
	ST(0) = &sv_yes;
    }
#line 1318 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_ora_lob_append); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_append)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::ora_lob_append(dbh, locator, data)");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
	SV *	data = ST(2);
#line 222 "Oracle.xs"
    D_imp_dbh(dbh);
    ub4 amtp;
    STRLEN data_len; /* bytes not chars */
    dvoid *bufp;
    sword status;
    /*ub4 startp;*/
    ub1 csform;
    ub2 csid;
#line 1342 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "locator is not of type OCILobLocatorPtr");
#line 231 "Oracle.xs"
    csid = 0;
    csform = SQLCS_IMPLICIT;
    bufp = SvPV(data, data_len);
    amtp = data_len;
    /* if locator is CLOB and data is UTF8 and not in bytes pragma */
    /* if (1 && SvUTF8(data) && !IN_BYTES) */
    /* added by lab: */
    /* LAB do something about length here? see above comment */
    OCILobCharSetForm_log_stat( imp_dbh->envhp, imp_dbh->errhp, locator, &csform, status );
    if (status != OCI_SUCCESS) {
        oci_error(dbh, imp_dbh->errhp, status, "OCILobCharSetForm");
	ST(0) = &sv_undef;
        return;
    }
#ifdef OCI_ATTR_CHARSET_ID
    /* Effectively only used so AL32UTF8 works properly */
    OCILobCharSetId_log_stat( imp_dbh->envhp, imp_dbh->errhp, locator, &csid, status );
    if (status != OCI_SUCCESS) {
        oci_error(dbh, imp_dbh->errhp, status, "OCILobCharSetId");
	ST(0) = &sv_undef;
        return;
    }
#endif /* OCI_ATTR_CHARSET_ID */
    /* if data is utf8 but charset isn't then switch to utf8 csid */
    csid = (SvUTF8(data) && !CS_IS_UTF8(csid)) ? utf8_csid : CSFORM_IMPLIED_CSID(csform);
#if !defined(ORA_OCI_8) && defined(OCI_HTYPE_DIRPATH_FN_CTX) /* Oracle is >= 9.0 */
    OCILobWriteAppend_log_stat(imp_dbh->svchp, imp_dbh->errhp, locator,
			       &amtp, bufp, (ub4)data_len, OCI_ONE_PIECE,
			       NULL, NULL,
			       csid, csform, status);
    if (status != OCI_SUCCESS) {
       oci_error(dbh, imp_dbh->errhp, status, "OCILobWriteAppend");
       ST(0) = &sv_undef;
    }
    else {
       ST(0) = &sv_yes;
    }
#else
    OCILobGetLength_log_stat(imp_dbh->svchp, imp_dbh->errhp, locator, &startp, status);
    if (status != OCI_SUCCESS) {
       oci_error(dbh, imp_dbh->errhp, status, "OCILobGetLength");
       ST(0) = &sv_undef;
    } else {
       /* start one after the end -- the first position in the LOB is 1 */
       startp++;
       if (DBIS->debug >= 2 )
            PerlIO_printf(DBILOGFP, "    Calling OCILobWrite with csid=%d csform=%d\n",csid, csform );
       OCILobWrite_log_stat(imp_dbh->svchp, imp_dbh->errhp, locator,
			    &amtp, startp,
			    bufp, (ub4)data_len, OCI_ONE_PIECE,
			    NULL, NULL,
			    csid, csform , status);
       if (status != OCI_SUCCESS) {
	  oci_error(dbh, imp_dbh->errhp, status, "OCILobWrite");
	  ST(0) = &sv_undef;
       }
       else {
	  ST(0) = &sv_yes;
       }
    }
#endif
#line 1412 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_ora_lob_read); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_read)
{
    dXSARGS;
    if (items != 4)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::ora_lob_read(dbh, locator, offset, length)");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
	UV	offset = (UV)SvUV(ST(2));
	UV	length = (UV)SvUV(ST(3));
#line 301 "Oracle.xs"
    D_imp_dbh(dbh);
    ub4 amtp;
    STRLEN bufp_len;
    SV *dest_sv;
    dvoid *bufp;
    sword status;
    ub1 csform;
#line 1436 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "locator is not of type OCILobLocatorPtr");
#line 309 "Oracle.xs"
    csform = SQLCS_IMPLICIT;
    dest_sv = sv_2mortal(newSV(length*4)); /*LAB: crude hack that works... tim did it else where XXX */
    SvPOK_on(dest_sv);
    bufp_len = SvLEN(dest_sv);	/* XXX bytes not chars? (lab: yes) */
    bufp = SvPVX(dest_sv);
    amtp = length;	/* if utf8 and clob/nclob: in: chars, out: bytes */
    /* http://www.lc.leidenuniv.nl/awcourse/oracle/appdev.920/a96584/oci16m40.htm#427818 */
    /* if locator is CLOB and data is UTF8 and not in bytes pragma */
    /* if (0 && SvUTF8(dest_sv) && !IN_BYTES) { amtp = sv_len_utf8(dest_sv); }  */
    /* added by lab: */
    OCILobCharSetForm_log_stat( imp_dbh->envhp, imp_dbh->errhp, locator, &csform, status );
    if (status != OCI_SUCCESS) {
        oci_error(dbh, imp_dbh->errhp, status, "OCILobCharSetForm");
	dest_sv = &sv_undef;
        return;
    }
    OCILobRead_log_stat(imp_dbh->svchp, imp_dbh->errhp, locator,
	    &amtp, (ub4)offset, /* offset starts at 1 */
	    bufp, (ub4)bufp_len,
	    0, 0, (ub2)0, csform, status);
    if (status != OCI_SUCCESS) {
        oci_error(dbh, imp_dbh->errhp, status, "OCILobRead");
        dest_sv = &sv_undef;
    }
    else {
        SvCUR(dest_sv) = amtp; /* always bytes here */
        *SvEND(dest_sv) = '\0';
	if (CSFORM_IMPLIES_UTF8(csform))
	    SvUTF8_on(dest_sv);

    }
    ST(0) = dest_sv;
#line 1477 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_ora_lob_trim); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_trim)
{
    dXSARGS;
    if (items != 3)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::ora_lob_trim(dbh, locator, length)");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
	UV	length = (UV)SvUV(ST(2));
#line 348 "Oracle.xs"
    D_imp_dbh(dbh);
    sword status;
#line 1495 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "locator is not of type OCILobLocatorPtr");
#line 351 "Oracle.xs"
    OCILobTrim_log_stat(imp_dbh->svchp, imp_dbh->errhp, locator, length, status);
    if (status != OCI_SUCCESS) {
        oci_error(dbh, imp_dbh->errhp, status, "OCILobTrim");
	ST(0) = &sv_undef;
    }
    else {
	ST(0) = &sv_yes;
    }
#line 1512 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__db_ora_lob_length); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__db_ora_lob_length)
{
    dXSARGS;
    if (items != 2)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::db::ora_lob_length(dbh, locator)");
    {
	SV *	dbh = ST(0);
	OCILobLocator *	locator;
#line 365 "Oracle.xs"
    D_imp_dbh(dbh);
    sword status;
    ub4 len = 0;
#line 1530 "Oracle.c"

	if (sv_derived_from(ST(1), "OCILobLocatorPtr")) {
	    IV tmp = SvIV((SV*)SvRV(ST(1)));
	    locator = INT2PTR(OCILobLocator *,tmp);
	}
	else
	    Perl_croak(aTHX_ "locator is not of type OCILobLocatorPtr");
#line 369 "Oracle.xs"
    OCILobGetLength_log_stat(imp_dbh->svchp, imp_dbh->errhp, locator, &len, status);
    if (status != OCI_SUCCESS) {
        oci_error(dbh, imp_dbh->errhp, status, "OCILobTrim");
	ST(0) = &sv_undef;
    }
    else {
	ST(0) = sv_2mortal(newSVuv(len));
    }
#line 1547 "Oracle.c"
    }
    XSRETURN(1);
}

XS(XS_DBD__Oracle__dr_init_oci); /* prototype to pass -Wmissing-prototypes */
XS(XS_DBD__Oracle__dr_init_oci)
{
    dXSARGS;
    if (items != 1)
	Perl_croak(aTHX_ "Usage: DBD::Oracle::dr::init_oci(drh)");
    {
	SV *	drh = ST(0);
#line 386 "Oracle.xs"
    D_imp_drh(drh);
	dbd_init_oci(DBIS) ;
	dbd_init_oci_drh(imp_drh) ;
#line 1564 "Oracle.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_DBD__Oracle); /* prototype to pass -Wmissing-prototypes */
XS(boot_DBD__Oracle)
{
    dXSARGS;
    char* file = __FILE__;

    XS_VERSION_BOOTCHECK ;

    {
        CV * cv ;

        cv = newXS("DBD::Oracle::ORA_CHAR", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 96 ;
        cv = newXS("DBD::Oracle::ORA_ROWID", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 11 ;
        cv = newXS("DBD::Oracle::ORA_MLSLABEL", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 105 ;
        cv = newXS("DBD::Oracle::ORA_CLOB", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 112 ;
        cv = newXS("DBD::Oracle::ORA_RAW", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 23 ;
        cv = newXS("DBD::Oracle::SQLCS_IMPLICIT", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = SQLCS_IMPLICIT ;
        cv = newXS("DBD::Oracle::ORA_SYSDBA", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x0002 ;
        cv = newXS("DBD::Oracle::ORA_BLOB", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 113 ;
        cv = newXS("DBD::Oracle::ORA_STRING", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 5 ;
        cv = newXS("DBD::Oracle::ORA_VARCHAR2", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Oracle::ORA_RSET", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 116 ;
        cv = newXS("DBD::Oracle::SQLCS_NCHAR", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = SQLCS_NCHAR ;
        cv = newXS("DBD::Oracle::ORA_LONGRAW", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 24 ;
        cv = newXS("DBD::Oracle::constant", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Oracle::ORA_NUMBER", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 2 ;
        cv = newXS("DBD::Oracle::ORA_NTY", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 108 ;
        cv = newXS("DBD::Oracle::ORA_SYSOPER", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 0x0004 ;
        cv = newXS("DBD::Oracle::ORA_CHARZ", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 97 ;
        cv = newXS("DBD::Oracle::ORA_LONG", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 8 ;
        cv = newXS("DBD::Oracle::ORA_DATE", XS_DBD__Oracle_constant, file);
        XSANY.any_i32 = 12 ;
        newXS("DBD::Oracle::ORA_OCI", XS_DBD__Oracle_ORA_OCI, file);
        newXS("DBD::Oracle::ora_env_var", XS_DBD__Oracle_ora_env_var, file);
#if XSubPPtmpAAAA
        newXS("DBD::Oracle::ora_cygwin_set_env", XS_DBD__Oracle_ora_cygwin_set_env, file);
#endif
#if XSubPPtmpAAAB
        cv = newXS("DBD::Oracle::dr::disconnect_all", XS_DBD__Oracle__dr_discon_all_, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Oracle::dr::discon_all_", XS_DBD__Oracle__dr_discon_all_, file);
        XSANY.any_i32 = 0 ;
#endif
#if XSubPPtmpAAAC
        newXS("DBD::Oracle::dr::data_sources", XS_DBD__Oracle__dr_data_sources, file);
#endif
        newXS("DBD::Oracle::db::_login", XS_DBD__Oracle__db__login, file);
        newXS("DBD::Oracle::db::selectall_arrayref", XS_DBD__Oracle__db_selectall_arrayref, file);
        cv = newXS("DBD::Oracle::db::selectrow_array", XS_DBD__Oracle__db_selectrow_arrayref, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Oracle::db::selectrow_arrayref", XS_DBD__Oracle__db_selectrow_arrayref, file);
        XSANY.any_i32 = 0 ;
#if XSubPPtmpAAAD
        newXS("DBD::Oracle::db::do", XS_DBD__Oracle__db_do, file);
#endif
#if XSubPPtmpAAAE
        newXS("DBD::Oracle::db::last_insert_id", XS_DBD__Oracle__db_last_insert_id, file);
#endif
        newXS("DBD::Oracle::db::commit", XS_DBD__Oracle__db_commit, file);
        newXS("DBD::Oracle::db::rollback", XS_DBD__Oracle__db_rollback, file);
        newXS("DBD::Oracle::db::disconnect", XS_DBD__Oracle__db_disconnect, file);
        newXS("DBD::Oracle::db::STORE", XS_DBD__Oracle__db_STORE, file);
        newXS("DBD::Oracle::db::FETCH", XS_DBD__Oracle__db_FETCH, file);
        newXS("DBD::Oracle::db::DESTROY", XS_DBD__Oracle__db_DESTROY, file);
#if XSubPPtmpAAAF
        newXS("DBD::Oracle::db::take_imp_data", XS_DBD__Oracle__db_take_imp_data, file);
#endif
#if XSubPPtmpAAAG
        newXS("DBD::Oracle::db::data_sources", XS_DBD__Oracle__db_data_sources, file);
#endif
        newXS("DBD::Oracle::st::_prepare", XS_DBD__Oracle__st__prepare, file);
#if XSubPPtmpAAAH
        newXS("DBD::Oracle::st::rows", XS_DBD__Oracle__st_rows, file);
#endif
#if XSubPPtmpAAAI
        newXS("DBD::Oracle::st::bind_col", XS_DBD__Oracle__st_bind_col, file);
#endif
        newXS("DBD::Oracle::st::bind_param", XS_DBD__Oracle__st_bind_param, file);
        newXS("DBD::Oracle::st::bind_param_inout", XS_DBD__Oracle__st_bind_param_inout, file);
        newXS("DBD::Oracle::st::execute", XS_DBD__Oracle__st_execute, file);
#if XSubPPtmpAAAJ
        newXS("DBD::Oracle::st::execute_for_fetch", XS_DBD__Oracle__st_execute_for_fetch, file);
#endif
        cv = newXS("DBD::Oracle::st::fetchrow_arrayref", XS_DBD__Oracle__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 0 ;
        cv = newXS("DBD::Oracle::st::fetch", XS_DBD__Oracle__st_fetchrow_arrayref, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Oracle::st::fetchrow", XS_DBD__Oracle__st_fetchrow_array, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Oracle::st::fetchrow_array", XS_DBD__Oracle__st_fetchrow_array, file);
        XSANY.any_i32 = 0 ;
        newXS("DBD::Oracle::st::fetchall_arrayref", XS_DBD__Oracle__st_fetchall_arrayref, file);
        newXS("DBD::Oracle::st::finish", XS_DBD__Oracle__st_finish, file);
        newXS("DBD::Oracle::st::blob_read", XS_DBD__Oracle__st_blob_read, file);
        newXS("DBD::Oracle::st::STORE", XS_DBD__Oracle__st_STORE, file);
        cv = newXS("DBD::Oracle::st::FETCH", XS_DBD__Oracle__st_FETCH_attrib, file);
        XSANY.any_i32 = 1 ;
        cv = newXS("DBD::Oracle::st::FETCH_attrib", XS_DBD__Oracle__st_FETCH_attrib, file);
        XSANY.any_i32 = 0 ;
        newXS("DBD::Oracle::st::DESTROY", XS_DBD__Oracle__st_DESTROY, file);
        newXS("DBD::Oracle::st::ora_fetch", XS_DBD__Oracle__st_ora_fetch, file);
        newXS("DBD::Oracle::st::ora_execute_array", XS_DBD__Oracle__st_ora_execute_array, file);
        newXS("DBD::Oracle::st::cancel", XS_DBD__Oracle__st_cancel, file);
        newXS("DBD::Oracle::db::reauthenticate", XS_DBD__Oracle__db_reauthenticate, file);
        newXS("DBD::Oracle::db::ora_lob_write", XS_DBD__Oracle__db_ora_lob_write, file);
        newXS("DBD::Oracle::db::ora_lob_append", XS_DBD__Oracle__db_ora_lob_append, file);
        newXS("DBD::Oracle::db::ora_lob_read", XS_DBD__Oracle__db_ora_lob_read, file);
        newXS("DBD::Oracle::db::ora_lob_trim", XS_DBD__Oracle__db_ora_lob_trim, file);
        newXS("DBD::Oracle::db::ora_lob_length", XS_DBD__Oracle__db_ora_lob_length, file);
        newXS("DBD::Oracle::dr::init_oci", XS_DBD__Oracle__dr_init_oci, file);
    }

    /* Initialisation Section */

#if XSubPPtmpAAAA
#endif
#line 18 "Oracle.xsi"
    items = 0;  /* avoid 'unused variable' warning */
    DBISTATE_INIT;
    /* XXX this interface will change: */
    DBI_IMP_SIZE("DBD::Oracle::dr::imp_data_size", sizeof(imp_drh_t));
    DBI_IMP_SIZE("DBD::Oracle::db::imp_data_size", sizeof(imp_dbh_t));
    DBI_IMP_SIZE("DBD::Oracle::st::imp_data_size", sizeof(imp_sth_t));
    dbd_init(DBIS);

#if XSubPPtmpAAAB
#endif
#if XSubPPtmpAAAC
#endif
#if XSubPPtmpAAAD
#endif
#if XSubPPtmpAAAE
#endif
#if XSubPPtmpAAAF
#endif
#if XSubPPtmpAAAG
#endif
#if XSubPPtmpAAAH
#endif
#if XSubPPtmpAAAI
#endif
#if XSubPPtmpAAAJ
#endif
#line 1734 "Oracle.c"

    /* End of Initialisation Section */

    XSRETURN_YES;
}

