<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<link rel="stylesheet" type="text/css" href="../../../scineplex.css">
<title>DBD::Oracle - Oracle database driver for the DBI module</title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:" />
</head>

<body>

<script>writelinks('__top__',3);</script>
<h1><a>DBD::Oracle - Oracle database driver for the DBI module</a></h1>
<p><a name="__index__"></a></p>

<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<li><a href="#connecting_to_oracle">CONNECTING TO ORACLE</a></li>
	<ul>

		<li><a href="#connecting_without_environment_variables_or_tnsname_ora_file">Connecting without environment variables or tnsname.ora file</a></li>
		<li><a href="#oracle_environment_variables">Oracle Environment Variables</a></li>
		<li><a href="#connection_examples_using_dbd__oracle">Connection Examples Using DBD::Oracle</a></li>
		<li><a href="#optimizing_oracle_s_listener">Optimizing Oracle's listener</a></li>
		<li><a href="#oracle_utilities">Oracle utilities</a></li>
		<li><a href="#constants">Constants</a></li>
		<li><a href="#connect_attributes">Connect Attributes</a></li>
		<li><a href="#database_handle_attributes">Database Handle Attributes</a></li>
		<li><a href="#statement_handle_attributes">Statement Handle Attributes</a></li>
		<li><a href="#prepare_attributes">Prepare Attributes</a></li>
		<li><a href="#placeholder_binding_attributes">Placeholder Binding Attributes</a></li>
		<li><a href="#trailing_spaces">Trailing Spaces</a></li>
	</ul>

	<li><a href="#metadata">Metadata</a></li>
	<ul>

		<li><a href="#get_info__"><code>get_info()</code></a></li>
		<li><a href="#table_info__"><code>table_info()</code></a></li>
		<li><a href="#primary_key_info__"><code>primary_key_info()</code></a></li>
		<li><a href="#foreign_key_info__"><code>foreign_key_info()</code></a></li>
		<li><a href="#column_info__"><code>column_info()</code></a></li>
	</ul>

	<li><a href="#unicode">Unicode</a></li>
	<ul>

		<li><a href="#perl_and_unicode">Perl and Unicode</a></li>
		<li><a href="#oracle_and_unicode">Oracle and Unicode</a></li>
		<li><a href="#oracle_utf8_is_not_utf8">Oracle UTF8 is not UTF-8</a></li>
		<li><a href="#dbd__oracle_and_unicode">DBD::Oracle and Unicode</a></li>
		<li><a href="#dbd__oracle_and_other_character_sets_and_encodings">DBD::Oracle and Other Character Sets and Encodings</a></li>
	</ul>

	<li><a href="#other_data_types">Other Data Types</a></li>
	<li><a href="#pl_sql_examples">PL/SQL Examples</a></li>
	<li><a href="#private_database_handle_functions">Private database handle functions</a></li>
	<ul>

		<li><a href="#plsql_errstr">plsql_errstr</a></li>
		<li><a href="#dbms_output_enable___dbms_output_put___dbms_output_get">dbms_output_enable / dbms_output_put / dbms_output_get</a></li>
	</ul>

	<li><a href="#prepare_postponed_till_execute">Prepare postponed till execute</a></li>
	<li><a href="#handling_lobs">Handling LOBs</a></li>
	<ul>

		<li><a href="#simple_usage">Simple Usage</a></li>
		<li><a href="#lob_support_in_pl_sql">LOB support in PL/SQL</a></li>
		<li><a href="#lob_locator_methods">LOB Locator Methods</a></li>
		<li><a href="#lob_locator_method_examples">LOB Locator Method Examples</a></li>
		<li><a href="#example__inserting_a_new_row_with_large_data">Example: Inserting a new row with large data</a></li>
		<li><a href="#example__updating_an_existing_row_with_large_data">Example: Updating an existing row with large data</a></li>
		<li><a href="#example__streaming_character_data_from_the_database">Example: Streaming character data from the database</a></li>
		<li><a href="#example__truncating_existing_large_data">Example: Truncating existing large data</a></li>
	</ul>

	<li><a href="#binding_cursors">Binding Cursors</a></li>
	<li><a href="#fetching_nested_cursors">Fetching Nested Cursors</a></li>
	<ul>

		<li><a href="#prefetching_nested_cursors">Pre-fetching Nested Cursors</a></li>
	</ul>

	<li><a href="#returning_a_value_from_an_insert">Returning A Value from an INSERT</a></li>
	<li><a href="#returning_a_recordset">Returning A Recordset</a></li>
	<li><a href="#timezones">Timezones</a></li>
	<li><a href="#oracle_related_links">Oracle Related Links</a></li>
	<ul>

		<li><a href="#oracle_on_linux">Oracle on Linux</a></li>
		<li><a href="#free_oracle_tools_and_links">Free Oracle Tools and Links</a></li>
		<li><a href="#commercial_oracle_tools_and_links">Commercial Oracle Tools and Links</a></li>
	</ul>

	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#acknowledgements">ACKNOWLEDGEMENTS</a></li>
	<li><a href="#maintainer">MAINTAINER</a></li>
	<li><a href="#copyright">COPYRIGHT</a></li>
	<li><a href="#contributing">CONTRIBUTING</a></li>
	<ul>

		<li><a href="#how_to_create_a_patch_using_subversion">How to create a patch using Subversion</a></li>
		<li><a href="#how_to_create_a_patch_without_subversion">How to create a patch without Subversion</a></li>
		<li><a href="#speak_before_you_patch">Speak before you patch</a></li>
	</ul>

</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>DBD::Oracle - Oracle database driver for the DBI module</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">"dbi:Oracle:$dbname"</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">"dbi:Oracle:host=$host;sid=$sid"</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># See the DBI module documentation for full details</span>
</pre>
<pre>
  <span class="comment"># for some advanced uses you may need Oracle type values:</span>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>DBD::Oracle is a Perl module which works with the DBI module to provide
access to Oracle databases.</p>
<p>
</p>
<hr />
<h1><a name="connecting_to_oracle">CONNECTING TO ORACLE</a></h1>
<p>This is a topic which often causes problems. Mainly due to Oracle's many
and sometimes complex ways of specifying and connecting to databases.
(James Taylor and Lane Sharman have contributed much of the text in
this section.)</p>
<p>
</p>
<h2><a name="connecting_without_environment_variables_or_tnsname_ora_file">Connecting without environment variables or tnsname.ora file</a></h2>
<p>If you use the <code>host=$host;sid=$sid</code> style syntax, for example:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">"dbi:Oracle:host=myhost.com;sid=ORCL"</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">);</span>
</pre>
<p>then DBD::Oracle will construct a full connection descriptor string
for you and Oracle will not need to consult the tnsname.ora file.</p>
<p>If a <code>port</code> number is not specified then the descriptor will try both
1526 and 1521 in that order (e.g., new then old).  You can check which
<code>port(s)</code> are in use by typing ``$ORACLE_HOME/bin/lsnrctl stat'' on the server.</p>
<p>
</p>
<h2><a name="oracle_environment_variables">Oracle Environment Variables</a></h2>
<p>Oracle typically uses two environment variables to specify default
connections: ORACLE_SID and TWO_TASK.</p>
<p>ORACLE_SID is really unnecessary to set since TWO_TASK provides the
same functionality in addition to allowing remote connections.</p>
<pre>
  % setenv TWO_TASK T:hostname:ORACLE_SID            # for csh shell
  $ TWO_TASK=T:hostname:ORACLE_SID export TWO_TASK   # for sh shell</pre>
<pre>
  % sqlplus username/password</pre>
<p>Note that if you have *both* local and remote databases, and you
have ORACLE_SID *and* TWO_TASK set, and you don't specify a fully
qualified connect string on the command line, TWO_TASK takes precedence
over ORACLE_SID (i.e. you get connected to remote system).</p>
<pre>
  TWO_TASK=P:sid</pre>
<p>will use the pipe driver for local connections using SQL*Net v1.</p>
<pre>
  TWO_TASK=T:machine:sid</pre>
<p>will use TCP/IP (or D for DECNET, etc.) for remote SQL*Net v1 connection.</p>
<pre>
  TWO_TASK=dbname</pre>
<p>will use the info stored in the SQL*Net v2 <em>tnsnames.ora</em>
configuration file for local or remote connections.</p>
<p>The ORACLE_HOME environment variable should be set correctly.
In general, the value used should match the version of Oracle that
was used to build DBD::Oracle.  If using dynamic linking then
ORACLE_HOME should match the version of Oracle that will be used
to load in the Oracle client libraries (via LD_LIBRARY_PATH, ldconfig,
or similar on Unix).</p>
<p>ORACLE_HOME can be left unset if you aren't using any of Oracle's
executables, but it is <em>not</em> recommended and error messages may not display.
It should be set to the ORACLE_HOME directory of the version of Oracle
that DBD::Oracle was compiled with.</p>
<p>Discouraging the use of ORACLE_SID makes it easier on the users to see
what is going on. (It's unfortunate that TWO_TASK couldn't be renamed,
since it makes no sense to the end user, and doesn't have the ORACLE prefix).</p>
<p>
</p>
<h2><a name="connection_examples_using_dbd__oracle">Connection Examples Using DBD::Oracle</a></h2>
<p>First, how to connect to a local database <em>without</em> using a Listener:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:SID'</span><span class="operator">,</span><span class="string">'scott'</span><span class="operator">,</span> <span class="string">'tiger'</span><span class="operator">);</span>
</pre>
<p>you can also leave the SID empty:</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'scott'</span><span class="operator">,</span> <span class="string">'tiger'</span><span class="operator">);</span>
</pre>
<p>in which case Oracle client code will use the ORACLE_SID environment
variable (if TWO_TASK env var isn't defined).</p>
<p>Below are various ways of connecting to an oracle database using
SQL*Net 1.x and SQL*Net 2.x.  ``Machine'' is the computer the database is
running on, ``SID'' is the SID of the database, ``DB'' is the SQL*Net 2.x
connection descriptor for the database.</p>
<p><strong>Note:</strong> Some of these formats may not work with Oracle 8+.</p>
<pre>
  <span class="keyword">BEGIN</span> <span class="operator">{</span>
     <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORACLE_HOME</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">'/home/oracle/product/7.x.x'</span><span class="operator">;</span>
     <span class="variable">$ENV</span><span class="operator">{</span><span class="string">TWO_TASK</span><span class="operator">}</span>    <span class="operator">=</span> <span class="string">'DB'</span><span class="operator">;</span>
  <span class="operator">}</span>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'scott'</span><span class="operator">,</span> <span class="string">'tiger'</span><span class="operator">);</span>
  <span class="comment">#  - or -</span>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'scott/tiger'</span><span class="operator">);</span>
</pre>
<p>Refer to your Oracle documentatiion for valid values of TWO_TASK.</p>
<p>Here are some variations (not setting TWO_TASK) in order of preference:</p>
<pre>
  $dbh = DBI-&gt;connect('dbi:Oracle:DB','username','password')</pre>
<pre>
  $dbh = DBI-&gt;connect('dbi:Oracle:DB','username/password','')</pre>
<pre>
  $dbh = DBI-&gt;connect('dbi:Oracle:','username@DB','password')</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:host=foobar;sid=ORCL;port=1521'</span><span class="operator">,</span> <span class="string">'scott/tiger'</span><span class="operator">,</span> <span class="string">''</span><span class="operator">)</span>
</pre>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span> <span class="string">q{scott/tiger@(DESCRIPTION=
  (ADDRESS=(PROTOCOL=TCP)(HOST= foobar)(PORT=1521))
  (CONNECT_DATA=(SID=ORCL)))}</span><span class="operator">,</span> <span class="string">""</span><span class="operator">)</span>
</pre>
<p>If you are having problems with login taking a long time (&gt;10 secs say)
then you might have tripped up on an Oracle bug. You can try using one
of the ...@DB variants as a workaround. E.g.,</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">''</span><span class="operator">,</span><span class="string">'username/password@DB'</span><span class="operator">,</span><span class="string">''</span><span class="operator">);</span>
</pre>
<p>On the other hand, that may cause you to trip up on another Oracle bug
that causes alternating connection attempts to fail! (In reality only
a small proportion of people experience these problems.)</p>
<p>To connect to a local database with a user which has been set-up to
authenticate via the OS (``ALTER USER username IDENTIFIED EXTERNALLY''):</p>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:'</span><span class="operator">,</span><span class="string">'/'</span><span class="operator">,</span><span class="string">''</span><span class="operator">);</span>
</pre>
<p>Note the lack of a connection name (use the ORACLE_SID environment
variable). If an explicit SID is used you'll probably get an ORA-01004 error.</p>
<p>That only works for local databases. (Authentication to remote Oracle
databases using your unix login name without a password and is possible
but it's not secure and not recommended so not documented here. If you
can't find the information elsewhere then you probably shouldn't be
trying to do it.)</p>
<p>
</p>
<h2><a name="optimizing_oracle_s_listener">Optimizing Oracle's listener</a></h2>
<p>[By Lane Sharman &lt;<a href="mailto:lane@bienlogic.com">lane@bienlogic.com</a>&gt;] I spent a LOT of time optimizing
listener.ora and I am including it here for anyone to benefit from. My
connections over tnslistener on the same humble Netra 1 take an average
of 10-20 milli seconds according to tnsping. If anyone knows how to
make it better, please let me know!</p>
<pre>
 LISTENER =
  (ADDRESS_LIST =
    (ADDRESS =
      (PROTOCOL = TCP)
      (Host = aa.bbb.cc.d)
      (Port = 1521)
      (QUEUESIZE=10)
    )
  )</pre>
<pre>
 STARTUP_WAIT_TIME_LISTENER = 0
 CONNECT_TIMEOUT_LISTENER = 10
 TRACE_LEVEL_LISTENER = OFF
 SID_LIST_LISTENER =
  (SID_LIST =
    (SID_DESC =
      (SID_NAME = xxxx)
      (ORACLE_HOME = /xxx/local/oracle7-3)
        (PRESPAWN_MAX = 40)
        (PRESPAWN_LIST=
        (PRESPAWN_DESC=(PROTOCOL=tcp) (POOL_SIZE=40) (TIMEOUT=120))
      )
    )
  )</pre>
<p>1) When the application is co-located on the host AND there is no need for
outside SQLNet connectivity, stop the listener. You do not need it. Get
your application/cgi/whatever working using pipes and shared memory. I am
convinced that this is one of the connection bugs (sockets over the same
machine). Note the $ENV{ORAPIPES} env var.  The essential code to do
this at the end of this section.</p>
<p>2) Be careful in how you implement the multi-threaded server. Currently I
am not using it in the initxxxx.ora file but will be doing some more testing.</p>
<p>3) Be sure to create user rollback segments and use them; do not use the
system rollback segments; however, you must also create a small rollback
space for the system as well.</p>
<p>5) Use large tuning settings and get lots of RAM. Check out all the
parameters you can set in v$parameters because there are quite a few not
documented you may to set in your initxxx.ora file.</p>
<p>6) Use svrmgrl to control oracle from the command line. Write lots of small
SQL scripts to get at V$ info.</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
  <span class="comment"># Environmental variables used by Oracle</span>
  <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORACLE_SID</span><span class="operator">}</span>   <span class="operator">=</span> <span class="string">"xxx"</span><span class="operator">;</span>
  <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORACLE_HOME</span><span class="operator">}</span>  <span class="operator">=</span> <span class="string">"/opt/oracle7"</span><span class="operator">;</span>
  <span class="variable">$ENV</span><span class="operator">{</span><span class="string">EPC_DISABLED</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">"TRUE"</span><span class="operator">;</span>
  <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORAPIPES</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">"V2"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbname</span> <span class="operator">=</span> <span class="string">"xxx"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbuser</span> <span class="operator">=</span> <span class="string">"xxx"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbpass</span> <span class="operator">=</span> <span class="string">"xxx"</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">"dbi:Oracle:$dbname"</span><span class="operator">,</span> <span class="variable">$dbuser</span><span class="operator">,</span> <span class="variable">$dbpass</span><span class="operator">)</span>
             <span class="operator">||</span> <span class="keyword">die</span> <span class="string">"Unale to connect to $dbname: $DBI::errstr\n"</span><span class="operator">;</span>
</pre>
<p>
</p>
<h2><a name="oracle_utilities">Oracle utilities</a></h2>
<p>If you are still having problems connecting then the Oracle adapters
utility may offer some help. Run these two commands:</p>
<pre>
  $ORACLE_HOME/bin/adapters
  $ORACLE_HOME/bin/adapters $ORACLE_HOME/bin/sqlplus</pre>
<p>and check the output. The ``Protocol Adapters'' section should be the
same.  It should include at least ``IPC Protocol Adapter'' and ``TCP/IP
Protocol Adapter''.</p>
<p>If it generates any errors which look relevant then please talk to yor
Oracle technical support (and not the dbi-users mailing list). Thanks.
Thanks to Mark Dedlow for this information.</p>
<p>
</p>
<h2><a name="constants">Constants</a></h2>
<dl>
<dt><strong><a name="item__3aora_session_modes">:ora_session_modes</a></strong>

<dd>
<pre>
  ORA_SYSDBA ORA_SYSOPER</pre>
</dd>
<dt><strong><a name="item__3aora_types">:ora_types</a></strong>

<dd>
<pre>
  ORA_VARCHAR2 ORA_STRING ORA_NUMBER ORA_LONG ORA_ROWID ORA_DATE
  ORA_RAW ORA_LONGRAW ORA_CHAR ORA_CHARZ ORA_MLSLABEL ORA_NTY
  ORA_CLOB ORA_BLOB ORA_RSET</pre>
</dd>
<dt><strong><a name="item_sqlcs_implicit">SQLCS_IMPLICIT</a></strong>

<dt><strong><a name="item_sqlcs_nchar">SQLCS_NCHAR</a></strong>

<dd>
<p>SQLCS_IMPLICIT and SQLCS_NCHAR are <em>character set form</em> values.
See notes about Unicode elsewhere in this document.</p>
</dd>
</li>
<dt><strong><a name="item_ora_oci">ORA_OCI</a></strong>

<dd>
<p>Oracle doesn't provide a formal API for determining the exact version
number of the OCI client library used, so DBD::Oracle has to go digging
(and sometimes has to more or less guess).  The ORA_OCI constant
holds the result of that process.</p>
</dd>
<dd>
<p>In string context ORA_OCI returns the full ``A.B.C.D'' version string.</p>
</dd>
<dd>
<p>In numeric context ORA_OCI returns the major.minor version number
(8.1, 9.2, 10.0 etc).  But note that version numbers are not actually
floating point and so if Oracle ever makes a release that has a two
digit minor version, such as <code>9.10</code> it will have a lower numeric
value than the preceeding <code>9.9</code> release. So use with care.</p>
</dd>
<dd>
<p>The contents and format of ORA_OCI are subject to change (it may,
for example, become a <em>version object</em> in later releases).
I recommend that you avoid checking for exact values.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="connect_attributes">Connect Attributes</a></h2>
<dl>
<dt><strong><a name="item_ora_session_mode">ora_session_mode</a></strong>

<dd>
<p>The ora_session_mode attribute can be used to connect with SYSDBA
authorization and SYSOPER authorization.
The ORA_SYSDBA and ORA_SYSOPER constants can be imported using</p>
</dd>
<dd>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_session_modes)</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>This is one case where setting ORACLE_SID may be useful since
connecting as SYSDBA or SYSOPER via SQL*Net is frequently disabled
for security reasons.</p>
</dd>
<dd>
<p>Example:</p>
</dd>
<dd>
<pre>
  <span class="variable">$dsn</span> <span class="operator">=</span> <span class="string">"dbi:Oracle:"</span><span class="operator">;</span>       <span class="comment"># no dbname here</span>
  <span class="variable">$ENV</span><span class="operator">{</span><span class="string">ORACLE_SID</span><span class="operator">}</span> <span class="operator">=</span> <span class="string">"orcl"</span><span class="operator">;</span>  <span class="comment"># set ORACLE_SID as needed</span>
  <span class="keyword">delete</span> <span class="variable">$ENV</span><span class="operator">{</span><span class="string">TWO_TASK</span><span class="operator">}</span><span class="operator">;</span>      <span class="comment"># make sure TWO_TASK isn't set</span>
</pre>
</dd>
<dd>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="string">""</span><span class="operator">,</span> <span class="string">""</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_session_mode</span> <span class="operator">=&gt;</span> <span class="variable">ORA_SYSDBA</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
</dd>
<dd>
<p>It has been reported that this only works if $dsn does not contain a SID
so that Oracle then uses the value of the ORACLE_SID (not TWO_TASK)
environment variable to connect to a local instance. Also the username
and password should be empty, and the user executing the script needs
to be part of the dba group or osdba group.</p>
</dd>
</li>
<dt><strong><a name="item_ora_oratab_orahome">ora_oratab_orahome</a></strong>

<dd>
<p>Passing a true value for the ora_oratab_orahome attribute will make
DBD::Oracle change $ENV{ORACLE_HOME} to make the Oracle home directory
specified in the <code>/etc/oratab</code> file <em>if</em> the database to connect to
is specified as a SID that exists in the oratab file, and DBD::Oracle was
built to use the Oracle 7 OCI API (not Oracle 8+).</p>
</dd>
</li>
<dt><strong><a name="item_ora_module_name">ora_module_name</a></strong>

<dd>
<p>After connecting to the database the value of this attribute is passed
to the <code>SET_MODULE()</code> function in the <code>DBMS_APPLICATION_INFO</code> PL/SQL
package. This can be used to identify the application to the DBA for
monitoring and performance tuning purposes. For example:</p>
</dd>
<dd>
<pre>
  <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_module_name</span> <span class="operator">=&gt;</span> <span class="variable">$0</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
</dd>
</li>
<dt><strong><a name="item_ora_dbh_share">ora_dbh_share</a></strong>

<dd>
<p>Needs at least Perl 5.8.0 compiled with ithreads. Allows to share database
connections between threads. The first connect will make the connection, 
all following calls to connect with the same ora_dbh_share attribute
will use the same database connection. The value must be a reference
to a already shared scalar which is initialized to an empty string.</p>
</dd>
<dd>
<pre>
  <span class="keyword">our</span> <span class="variable">$orashr</span> <span class="operator">:</span> <span class="variable">shared</span> <span class="operator">=</span> <span class="string">''</span> <span class="operator">;</span>
</pre>
</dd>
<dd>
<pre>
  <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span> <span class="operator">(</span><span class="variable">$dsn</span><span class="operator">,</span> <span class="variable">$user</span><span class="operator">,</span> <span class="variable">$passwd</span><span class="operator">,</span> <span class="operator">{</span><span class="string">ora_dbh_share</span> <span class="operator">=&gt;</span> <span class="operator">\</span><span class="variable">$orashr</span><span class="operator">}</span><span class="operator">)</span> <span class="operator">;</span>
</pre>
</dd>
</li>
<dt><strong><a name="item_ora_use_proc_connection">ora_use_proc_connection</a></strong>

<dd>
<p>This attribute allows to create a DBI handle for an existing SQLLIB
database connection. This can be used to share database connections
between Oracle ProC code and DBI running in an embedded Perl interpreter.
The SQLLIB connection id is appended after the ``dbi:Oracle:'' initial
argument to DBI::connect.</p>
</dd>
<dd>
<p>For example, if in ProC a connection is made like</p>
</dd>
<dd>
<pre>
    <span class="variable">EXEC</span> <span class="variable">SQL</span> <span class="variable">CONNECT</span> <span class="string">'user/pass@db'</span> <span class="variable">AT</span> <span class="string">'CONID'</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>the connection may be used from DBI after running something like</p>
</dd>
<dd>
<pre>
    <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">"dbi:Oracle:CONID"</span><span class="operator">,</span> <span class="string">""</span><span class="operator">,</span> <span class="string">""</span><span class="operator">,</span>
                           <span class="operator">{</span> <span class="string">ora_use_proc_connection</span> <span class="operator">=&gt;</span> <span class="number">1</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
</dd>
<dd>
<p>To disconnect, first call $dbh-&gt;disconnect(), then disconnect in ProC.</p>
</dd>
<dd>
<p>This attribute requires DBD::Oracle to be built with the -ProC
option to Makefile.PL.  It is not available with OCI_V7. Not tested
with Perl ithreads or with the ora_dbh_share connect attribute.</p>
</dd>
</li>
<dt><strong><a name="item_ora_envhp">ora_envhp</a></strong>

<dd>
<p>The first time a connection is made a new OCI 'environment' is
created by DBD::Oracle and stored in the driver handle.
Subsequent connects reuse (share) that same OCI environment
by default.</p>
</dd>
<dd>
<p>The ora_envhp attribute can be used to disable the reuse of the OCI
environment from a previous connect. If the value is <code>0</code> then
a new OCI environment is allocated and used for this connection.</p>
</dd>
<dd>
<p>The OCI environment is what holds information about the client side
context, such as the local NLS environment. So by altering %ENV and
setting ora_envhp to 0 you can create connections with different
NLS settings. This is most useful for testing.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="database_handle_attributes">Database Handle Attributes</a></h2>
<dl>
<dt><strong><a name="item_ora_ph_type"><code>ora_ph_type</code></a></strong>

<dd>
<p>The default placeholder data type for the database session.
The <code>TYPE</code> or <a href="#item_ora_type">ora_type</a> attributes to <a href="../../../site/lib/DBI/bind_param.html">bind_param in the DBI manpage</a> and
<a href="../../../site/lib/DBI/bind_param_inout.html">bind_param_inout in the DBI manpage</a> override the data type for individual placeholders.
The most frequent reason for using this attribute is to permit trailing spaces
in values passed by placeholders.</p>
</dd>
<dd>
<p>Constants for the values allowed for this attribute can be imported using</p>
</dd>
<dd>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>Only the following values are permitted for this attribute.</p>
</dd>
<dl>
<dt><strong><a name="item_ora_varchar2">ORA_VARCHAR2</a></strong>

<dd>
<p>Strip trailing spaces and allow embedded \0 bytes.
This is the normal default placeholder type.</p>
</dd>
</li>
<dt><strong><a name="item_ora_string">ORA_STRING</a></strong>

<dd>
<p>Don't strip trailing spaces and end the string at the first \0.</p>
</dd>
</li>
<dt><strong><a name="item_ora_char">ORA_CHAR</a></strong>

<dd>
<p>Don't strip trailing spaces and allow embedded \0.
Force 'blank-padded comparison semantics'.</p>
</dd>
</li>
</dl>
<dt><strong><a name="item_ora_parse_error_offset">ora_parse_error_offset</a></strong>

<dd>
<p>If the previous error was from a failed <code>prepare</code> due to a syntax error,
this attribute gives the offset into the <code>Statement</code> attribute where the
error was found.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="statement_handle_attributes">Statement Handle Attributes</a></h2>
<dl>
<dt><strong><a name="item_ora_array_chunk_size"><code>ora_array_chunk_size</code></a></strong>

<dd>
<p>Because of OCI limitations, DBD::Oracle needs to buffer up rows of
bind values in its <code>execute_for_fetch</code> implementation. This attribute
sets the number of rows to buffer at a time (default value is 1000).</p>
</dd>
<dd>
<p>The <code>execute_for_fetch</code> function will collect (at most) this many
rows in an array, send them of to the DB for execution, then go back
to collect the next chunk of rows and so on. This attribute can be
used to limit or extend the number of rows processed at a time.</p>
</dd>
<dd>
<p>Note that this attribute also applies to <code>execute_array</code>, since that
method is implemented using <code>execute_for_fetch</code>.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="prepare_attributes">Prepare Attributes</a></h2>
<p>These attributes may be used in the <code>\%attr</code> parameter of the
<a href="../../../site/lib/DBI/prepare.html">prepare in the DBI manpage</a> database handle method.</p>
<dl>
<dt><strong><a name="item_ora_placeholders">ora_placeholders</a></strong>

<dd>
<p>Set to false to disable processing of placeholders. Used mainly for loading a
PL/SQL package that has been <em>wrapped</em> with Oracle's <code>wrap</code> utility.</p>
</dd>
</li>
<dt><strong><a name="item_ora_parse_lang">ora_parse_lang</a></strong>

<dd>
<p>Tells the connected database how to interpret the SQL statement.
If 1 (default), the native SQL version for the database is used.
Other recognized values are 0 (old V6, treated as V7 in OCI8),
2 (old V7), 7 (V7), and 8 (V8).
All other values have the same effect as 1.</p>
</dd>
</li>
<dt><strong><a name="item_ora_auto_lob">ora_auto_lob</a></strong>

<dd>
<p>If true (the default), fetching retreives the contents of the CLOB or
BLOB column in most circumstances.  If false, fetching retreives the
Oracle ``LOB Locator'' of the CLOB or BLOB value.</p>
</dd>
<dd>
<p>See <a href="#handling_lobs">Handling LOBs</a> for more details.
See also the LOB tests in 05dbi.t of Oracle::OCI for examples
of how to use LOB Locators.</p>
</dd>
</li>
<dt><strong><a name="item_ora_check_sql">ora_check_sql</a></strong>

<dd>
<p>If 1 (default), force SELECT statements to be described in prepare().
If 0, allow SELECT statements to defer describe until execute().</p>
</dd>
<dd>
<p>See <a href="#prepare_postponed_till_execute">Prepare postponed till execute</a> for more information.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="placeholder_binding_attributes">Placeholder Binding Attributes</a></h2>
<p>These attributes may be used in the <code>\%attr</code> parameter of the
<a href="../../../site/lib/DBI/bind_param.html">bind_param in the DBI manpage</a> or <a href="../../../site/lib/DBI/bind_param_inout.html">bind_param_inout in the DBI manpage</a> statement handle methods.</p>
<dl>
<dt><strong><a name="item_ora_type">ora_type</a></strong>

<dd>
<p>Specify the placeholder's data type using an Oracle data type.
A fatal error is raised if <a href="#item_ora_type"><code>ora_type</code></a> and the DBI <code>TYPE</code> attribute
are used for the same placeholder.
Some of these types are not supported by the current version of
DBD::Oracle and will cause a fatal error if used.
Constants for the Oracle datatypes may be imported using</p>
</dd>
<dd>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
</dd>
<dd>
<p>Potentially useful values when DBD::Oracle was built using OCI 7 and later:</p>
</dd>
<dd>
<pre>
  ORA_VARCHAR2, ORA_STRING, ORA_LONG, ORA_RAW, ORA_LONGRAW,
  ORA_CHAR, ORA_MLSLABEL, ORA_RSET</pre>
</dd>
<dd>
<p>Additional values when DBD::Oracle was built using OCI 8 and later:</p>
</dd>
<dd>
<pre>
  ORA_CLOB, ORA_BLOB, ORA_NTY</pre>
</dd>
<dd>
<p>See <a href="#binding_cursors">Binding Cursors</a> for the correct way to use ORA_RSET.</p>
</dd>
<dd>
<p>See <a href="#handling_lobs">Handling LOBs</a> for how to use ORA_CLOB and ORA_BLOB.</p>
</dd>
<dd>
<p>See <a href="#other_data_types">Other Data Types</a> for more information.</p>
</dd>
<dd>
<p>See also <a href="../../../site/lib/DBI/placeholders_and_bind_values.html">Placeholders and Bind Values in the DBI manpage</a>.</p>
</dd>
</li>
<dt><strong><a name="item_ora_csform">ora_csform</a></strong>

<dd>
<p>Specify the OCI_ATTR_CHARSET_FORM for the bind value. Valid values
are SQLCS_IMPLICIT (1) and SQLCS_NCHAR (2). Both those constants can
be imported from the DBD::Oracle module. Rarely needed.</p>
</dd>
</li>
<dt><strong><a name="item_ora_csid">ora_csid</a></strong>

<dd>
<p>Specify the <em>integer</em> OCI_ATTR_CHARSET_ID for the bind value. 
Character set names can't be used currently.</p>
</dd>
</li>
<dt><strong><a name="item_ora_maxdata_size">ora_maxdata_size</a></strong>

<dd>
<p>Specify the integer OCI_ATTR_MAXDATA_SIZE for the bind value. 
May be needed if a character set conversion from client to server
causes the data to use more space and so fail with a truncation error.</p>
</dd>
</li>
</dl>
<p>
</p>
<h2><a name="trailing_spaces">Trailing Spaces</a></h2>
<p>The Oracle strips trailing spaces from VARCHAR placeholder
values and uses Nonpadded Comparison Semantics with the result.
This causes trouble if the spaces are needed for
comparison with a CHAR value or to prevent the value from
becoming '' which Oracle treats as NULL.
Look for Blank-padded Comparison Semantics and Nonpadded
Comparison Semantics in Oracle's SQL Reference or Server
SQL Reference for more details.</p>
<p>Please remember that using spaces as a value or at the end of
a value makes visually distinguishing values with different
numbers of spaces difficult and should be avoided.</p>
<p>To preserve trailing spaces in placeholder values, either change
the default placeholder type with <a href="#item_ora_ph_type">ora_ph_type</a> or the placeholder
type for a particular call to <a href="../../../site/lib/DBI/bind.html">bind in the DBI manpage</a> or <a href="../../../site/lib/DBI/bind_param_inout.html">bind_param_inout in the DBI manpage</a>
with <a href="#item_ora_type">ora_type</a> or <code>TYPE</code>.
Using <a href="#item_ora_char">ORA_CHAR</a> with <a href="#item_ora_type">ora_type</a> or <code>SQL_CHAR</code> with <code>TYPE</code>
allows the placeholder to be used with Padded Comparison Semantics
if the value it is being compared to is a CHAR, NCHAR, or literal.</p>
<p>
</p>
<hr />
<h1><a name="metadata">Metadata</a></h1>
<p>
</p>
<h2><a name="get_info__"><code>get_info()</code></a></h2>
<p>DBD::Oracle supports <code>get_info()</code>, but (currently) only a few info types.</p>
<p>
</p>
<h2><a name="table_info__"><code>table_info()</code></a></h2>
<p>DBD::Oracle supports attributes for <code>table_info()</code>.</p>
<p>In Oracle, the concept of <em>user</em> and <em>schema</em> is (currently) the
same. Because database objects are owned by an user, the owner names
in the data dictionary views correspond to schema names.
Oracle does not support catalogs so TABLE_CAT is ignored as
selection criterion.</p>
<p>Search patterns are supported for TABLE_SCHEM and TABLE_NAME.</p>
<p>TABLE_TYPE may contain a comma-separated list of table types.
The following table types are supported:</p>
<pre>
  TABLE
  VIEW
  SYNONYM
  SEQUENCE</pre>
<p>The result set is ordered by TABLE_TYPE, TABLE_SCHEM, TABLE_NAME.</p>
<p>The special enumerations of catalogs, schemas and table types are
supported. However, TABLE_CAT is always NULL.</p>
<p>An identifier is passed <em>as is</em>, i.e. as the user provides or
Oracle returns it.
<code>table_info()</code> performs a case-sensitive search. So, a selection
criterion should respect upper and lower case.
Normally, an identifier is case-insensitive. Oracle stores and
returns it in upper case. Sometimes, database objects are created
with quoted identifiers (for reserved words, mixed case, special
characters, ...). Such an identifier is case-sensitive (if not all
upper case). Oracle stores and returns it as given.
<code>table_info()</code> has no special quote handling, neither adds nor
removes quotes.</p>
<p>
</p>
<h2><a name="primary_key_info__"><code>primary_key_info()</code></a></h2>
<p>Oracle does not support catalogs so TABLE_CAT is ignored as
selection criterion.
The TABLE_CAT field of a fetched row is always NULL (undef).
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>If the primary key constraint was created without an identifier,
PK_NAME contains a system generated name with the form SYS_Cn.</p>
<p>The result set is ordered by TABLE_SCHEM, TABLE_NAME, KEY_SEQ.</p>
<p>An identifier is passed <em>as is</em>, i.e. as the user provides or
Oracle returns it.
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>
</p>
<h2><a name="foreign_key_info__"><code>foreign_key_info()</code></a></h2>
<p>This method (currently) supports the extended behavior of SQL/CLI, i.e. the
result set contains foreign keys that refer to primary <strong>and</strong> alternate keys.
The field UNIQUE_OR_PRIMARY distinguishes these keys.</p>
<p>Oracle does not support catalogs, so <code>$pk_catalog</code> and <code>$fk_catalog</code> are
ignored as selection criteria (in the new style interface).
The UK_TABLE_CAT and FK_TABLE_CAT fields of a fetched row are always
NULL (undef).
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>If the primary or foreign key constraints were created without an identifier,
UK_NAME or FK_NAME contains a system generated name with the form SYS_Cn.</p>
<p>The UPDATE_RULE field is always 3 ('NO ACTION'), because Oracle (currently)
does not support other actions.</p>
<p>The DELETE_RULE field may contain wrong values. This is a known Bug (#1271663)
in Oracle's data dictionary views. Currently (as of 8.1.7), 'RESTRICT' and
'SET DEFAULT' are not supported, 'CASCADE' is mapped correctly and all other
actions (incl. 'SET NULL') appear as 'NO ACTION'.</p>
<p>The DEFERABILITY field is always NULL, because this columns is
not present in the ALL_CONSTRAINTS view of older Oracle releases.</p>
<p>The result set is ordered by UK_TABLE_SCHEM, UK_TABLE_NAME, FK_TABLE_SCHEM,
FK_TABLE_NAME, ORDINAL_POSITION.</p>
<p>An identifier is passed <em>as is</em>, i.e. as the user provides or
Oracle returns it.
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>
</p>
<h2><a name="column_info__"><code>column_info()</code></a></h2>
<p>Oracle does not support catalogs so TABLE_CAT is ignored as
selection criterion.
The TABLE_CAT field of a fetched row is always NULL (undef).
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>The CHAR_OCTET_LENGTH field is (currently) always NULL (undef).</p>
<p>Don't rely on the values of the BUFFER_LENGTH field!
Especially the length of FLOATs may be wrong.</p>
<p>Datatype codes for non-standard types are subject to change.</p>
<p>Attention! The DATA_DEFAULT (COLUMN_DEF) column is of type LONG.</p>
<p>The result set is ordered by TABLE_SCHEM, TABLE_NAME, ORDINAL_POSITION.</p>
<p>An identifier is passed <em>as is</em>, i.e. as the user provides or
Oracle returns it.
See <a href="#table_info__">table_info()</a> for more detailed information.</p>
<p>
</p>
<hr />
<h1><a name="unicode">Unicode</a></h1>
<p>DBD::Oracle now supports Unicode UTF-8. There are, however, a number
of issues you should be aware of, so please read all this section
carefully.</p>
<p>In this section we'll discuss ``Perl and Unicode'', then ``Oracle and
Unicode'', and finally ``DBD::Oracle and Unicode''.</p>
<p>Information about Unicode in general can be found at:
<a href="http://www.unicode.org/">http://www.unicode.org/</a>. It is well worth reading because there are
many misconceptions about Unicode and you may be holding some of them.</p>
<p>
</p>
<h2><a name="perl_and_unicode">Perl and Unicode</a></h2>
<p>Perl began implementing Unicode with version 5.6, but the implementaion
did not mature until version 5.8 and later. If you plan to use Unicode
you are <em>strongly</em> urged to use perl 5.8.2 or later and to <em>carefully</em> read
the perl documention on Unicode:</p>
<pre>
   <a href="../../../lib/Pod/perldoc.html">perldoc</a> <a href="../../../lib/Pod/perluniintro.html">perluniintro</a>    # in perl 5.8 or later
   <a href="../../../lib/Pod/perldoc.html">perldoc</a> <a href="../../../lib/Pod/perlunicode.html">perlunicode</a></pre>
<p>And then read it again.</p>
<p>Perl's internal unicode format is UTF-8
which corresponds to the Oracle character set called AL32UTF8.</p>
<p>
</p>
<h2><a name="oracle_and_unicode">Oracle and Unicode</a></h2>
<p>Oracle supports many characters sets, including several different forms
of Unicode.  These include:</p>
<pre>
  AL16UTF16  =&gt;  valid for NCHAR columns (CSID=2000)
  UTF8       =&gt;  valid for NCHAR columns (CSID=871), deprecated
  AL32UTF8   =&gt;  valid for NCHAR and CHAR columns (CSID=873)</pre>
<p>When you create an Oracle database, you must specify the DATABASE 
character set (used for DDL, DML and CHAR datatypes) and the NATIONAL 
character set (used for NCHAR and NCLOB types).
The character sets used in your database can be found using:</p>
<pre>
  <span class="variable">$hash_ref</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_nls_parameters</span><span class="operator">()</span>
  <span class="variable">$database_charset</span> <span class="operator">=</span> <span class="variable">$hash_ref</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">NLS_CHARACTERSET</span><span class="operator">}</span><span class="operator">;</span>
  <span class="variable">$national_charset</span> <span class="operator">=</span> <span class="variable">$hash_ref</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">NLS_NCHAR_CHARACTERSET</span><span class="operator">}</span><span class="operator">;</span>
</pre>
<p>The Oracle 9.2 and later default for the national character set is AL16UTF16.
The default for the database character set is often US7ASCII.
Although many experienced DBAs will consider an 8bit character set like
WE8ISO8859P1 or WE8MSWIN1252.  To use any character set with Oracle
other than US7ASCII, requires that the NLS_LANG environment variable be set.
See the <a href="#international_nls___8bit_text_issues">International NLS / 8-bit text issues</a> section below.</p>
<p>You are strongly urged to read the Oracle Internationalization documentation
specifically with respect the choices and trade offs for creating
a databases for use with international character sets.</p>
<p>Oracle uses the NLS_LANG environment variable to indicate what
character set is being used on the client.  When fetching data Oracle
will convert from whatever the database character set is to the client
character set specified by NLS_LANG. Similarly, when sending data to
the database Oracle will convert from the character set specified by
NLS_LANG to the database character set.</p>
<p>The NLS_NCHAR environment variable can be used to define a different
character set for 'national' (NCHAR) character types.</p>
<p>Both UTF8 and AL32UTF32 can be used in NLS_LANG and NLS_NCHAR.
For example:</p>
<pre>
   NLS_LANG=AMERICAN_AMERICA.UTF8
   NLS_LANG=AMERICAN_AMERICA.AL32UTF8
   NLS_NCHAR=UTF8
   NLS_NCHAR=AL32UTF8</pre>
<p>Oracle 8 client libraries have a number of bugs related to character
set handling, especially when connected to an Oracle 9+ server.
For this reason a number of DBD::Oracle tests are disabled when
using an Oracle 8 client. If you wish to use Unicode, I recommend
upgrading client and server to Oracle 9 or later.</p>
<p>
</p>
<h2><a name="oracle_utf8_is_not_utf8">Oracle UTF8 is not UTF-8</a></h2>
<p>AL32UTF8 should be used in preference to UTF8 if it works for you,
which it should for Oracle 9.2 or later. If you're using an old
version of Oracle that doesn't support AL32UTF8 then you should
avoid using any Unicode characters that require surrogates, in other
words characters beyond the Unicode BMP (Basic Multilingual Plane).</p>
<p>That's because the character set that Oracle calls ``UTF8'' doesn't
conform to the UTF-8 standard in its handling of surrogate characters.
Technically the encoding that Oracle calls ``UTF8'' is known as ``CESU-8''.
Here are a couple of extracts from <a href="http://www.unicode.org/reports/tr26/">http://www.unicode.org/reports/tr26/</a>:</p>
<pre>
  CESU-8 is useful in 8-bit processing environments where binary
  collation with UTF-16 is required. It is designed and recommended
  for use only within products requiring this UTF-16 binary collation
  equivalence. It is not intended nor recommended for open interchange.</pre>
<pre>
  As a very small percentage of characters in a typical data stream
  are expected to be supplementary characters, there is a strong
  possibility that CESU-8 data may be misinterpreted as UTF-8.
  Therefore, all use of CESU-8 outside closed implementations is
  strongly discouraged, such as the emittance of CESU-8 in output
  files, markup language or other open transmission forms.</pre>
<p>Oracle uses this internally because it collates (sorts) in the same order
as UTF16, which is the basis of Oracle's internal collation definitions.</p>
<p>Rather than change UTF8 for clients Oracle chose to define a new character
set called ``AL32UTF8'' which does conform to the UTF-8 standard.
(The AL32UTF8 character set can't be used on the server because it
would break collation.)</p>
<p>Because of that, for the rest of this document we'll use ``AL32UTF8''.
If you're using an Oracle version below 9.2 you'll need to use ``UTF8''
until you upgrade.</p>
<p>
</p>
<h2><a name="dbd__oracle_and_unicode">DBD::Oracle and Unicode</a></h2>
<p>DBD::Oracle Unicode support has been implemented for Oracle versions 9
or greater, and perl version 5.6 or greater (though we <em>strongly</em>
suggest that you use perl 5.8.2 or later).</p>
<p>You can check which Oracle version your DBD::Oracle was built with by
importing the <a href="#item_ora_oci"><code>ORA_OCI</code></a> constant from DBD::Oracle.</p>
<p><strong>Fetching Data</strong></p>
<p>Any data returned from Oracle to DBD::Oracle in the AL32UTF8
character set will be marked as UTF-8 to ensure correct handling by perl.</p>
<p>For Oracle to return data in the AL32UTF8 character set the
NLS_LANG or NLS_NCHAR environment variable <em>must</em> be set as described
in the previous section.</p>
<p>When fetching NCHAR, NVARCHAR, or NCLOB data from Oracle, DBD::Oracle
will set the perl UTF-8 flag on the returned data if either NLS_NCHAR
is AL32UTF8, or NLS_NCHAR is not set and NLS_LANG is AL32UTF8.</p>
<p>When fetching other character data from Oracle, DBD::Oracle
will set the perl UTF-8 flag on the returned data if NLS_LANG is AL32UTF8.</p>
<p><strong>Sending Data using Placeholders</strong></p>
<p>Data bound to a placeholder is assumed to be in the default client
character set (specified by NLS_LANG) except for a few special
cases. These are listed here with the highest precedence first:</p>
<p>If the <a href="#item_ora_csid"><code>ora_csid</code></a> attribute is given to <code>bind_param()</code> then that
is passed to Oracle and takes precedence.</p>
<p>If the value is a Perl Unicode string (UTF-8) then DBD::Oracle
ensures that Oracle uses the Unicode character set, regardless of
the NLS_LANG and NLS_NCHAR settings.</p>
<p>If the placeholder is for inserting an NCLOB then the client NLS_NCHAR
character set is used. (That's useful but inconsistent with the other behaviour
so may change. Best to be explicit by using the <a href="#item_ora_csform"><code>ora_csform</code></a>
attribute.)</p>
<p>If the <a href="#item_ora_csform"><code>ora_csform</code></a> attribute is given to <code>bind_param()</code> then that
determines if the value should be assumed to be in the default
(NLS_LANG) or NCHAR (NLS_NCHAR) client character set.</p>
<pre>
   <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw( SQLCS_IMPLICIT SQLCS_NCHAR )</span><span class="operator">;</span>
   <span class="operator">...</span>
   <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="number">1</span><span class="operator">,</span> <span class="variable">$value</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_csform</span> <span class="operator">=&gt;</span> <span class="variable">SQLCS_NCHAR</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>or</p>
<pre>
   <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">ora_ph_csform</span><span class="operator">}</span> <span class="operator">=</span> <span class="variable">SQLCS_NCHAR</span><span class="operator">;</span> <span class="comment"># default for all future placeholders</span>
</pre>
<p><strong>Sending Data using SQL</strong></p>
<p>Oracle assumes the SQL statement is in the default client character
set (as specified by NLS_LANG). So Unicode strings containing
non-ASCII characters should not be used unless the default client
character set is AL32UTF8.</p>
<p>
</p>
<h2><a name="dbd__oracle_and_other_character_sets_and_encodings">DBD::Oracle and Other Character Sets and Encodings</a></h2>
<p>The only multi-byte Oracle character set supported by DBD::Oracle is
``AL32UTF8'' (and ``UTF8''). Single-byte character sets should work well.</p>
<p>
</p>
<hr />
<h1><a name="other_data_types">Other Data Types</a></h1>
<p>DBD::Oracle does not <em>explicitly</em> support most Oracle data types.
It simply asks Oracle to return them as strings and Oracle does so.
Mostly.  Similarly when binding placeholder values DBD::Oracle binds
them as strings and Oracle converts them to the appropriate type,
such as DATE, when used.</p>
<p>Some of these automatic conversions to and from strings use NLS
setings to control the formating for output and the parsing for
input. The most common example is the DATE type. The default NLS
format for DATE might be DD-MON-YYYY and so when a DATE type is
fetched that's how Oracle will format the date. NLS settings also
control the default parsing of strings into DATE values. An error
will be generated if the contents of the string don't match the
NLS format. If you're dealing in dates which don't match the default
NLS format then you can either change the default NLS format or, more
commonly, use TO_CHAR(field, ``format'') and TO_DATE(?, ``format'')
to explicitly specify formats for converting to and from strings.</p>
<p>A slightly more subtle problem can occur with NUMBER types. The
default NLS settings might format numbers with a fullstop (``<code>.</code>'')
to separate thousands and a comma (``<code>,</code>'') as the decimal point.
Perl will generate warnings and use incorrect values when numbers,
returned and formatted as strings in this way by Oracle, are used
in a numeric context.  You could explicitly convert each numeric
value using the <code>TO_CHAR(...)</code> function but that gets tedious very
quickly. The best fix is to change the NLS settings. That can be
done for an individual connection by doing:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="keyword">do</span><span class="operator">(</span><span class="string">"ALTER SESSION SET NLS_NUMERIC_CHARACTERS = '.,'"</span><span class="operator">);</span>
</pre>
<p>There are some types, like BOOLEAN, that Oracle does not automatically
convert to or from strings (pity).  These need to be converted
explicitly using SQL or PL/SQL functions.</p>
<p>Examples:</p>
<pre>
   <span class="comment"># DATE values</span>
   <span class="keyword">my</span> <span class="variable">$sth0</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">( &lt;&lt;</span><span class="here_document">SQL_END</span> <span class="operator">);</span><span class="here_document">
   SELECT username, TO_CHAR( created, ? )
      FROM all_users
      WHERE created &gt;= TO_DATE( ?, ? )
   </span><span class="here_document">SQL_END</span>
   <span class="variable">$sth0</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">(</span> <span class="string">'YYYY-MM-DD HH24:MI:SS'</span><span class="operator">,</span> <span class="string">"2003"</span><span class="operator">,</span> <span class="string">'YYYY'</span> <span class="operator">);</span>
</pre>
<pre>
   <span class="comment"># BOOLEAN values</span>
   <span class="keyword">my</span> <span class="variable">$sth2</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">( &lt;&lt;</span><span class="here_document">PLSQL_END</span> <span class="operator">);</span><span class="here_document">
   DECLARE
      b0 BOOLEAN;
      b1 BOOLEAN;
      o0 VARCHAR2(32);
      o1 VARCHAR2(32);
   </span>
</pre>
<pre>
      <span class="variable">FUNCTION</span> <span class="variable">to_bool</span><span class="operator">(</span> <span class="variable">i</span> <span class="variable">VARCHAR2</span> <span class="operator">)</span> <span class="variable">RETURN</span> <span class="variable">BOOLEAN</span> <span class="variable">IS</span>
      <span class="keyword">BEGIN</span>
         <span class="variable">IF</span>    <span class="variable">i</span> <span class="variable">IS</span> <span class="keyword">NULL</span>          <span class="variable">THEN</span> <span class="variable">RETURN</span> <span class="keyword">NULL</span><span class="operator">;</span>
         <span class="variable">ELSIF</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">'F'</span> <span class="variable">OR</span> <span class="variable">i</span> <span class="operator">=</span> <span class="string">'0'</span> <span class="variable">THEN</span> <span class="variable">RETURN</span> <span class="variable">FALSE</span><span class="operator">;</span>
         <span class="variable">ELSE</span>                          <span class="variable">RETURN</span> <span class="variable">TRUE</span><span class="operator">;</span>
         <span class="keyword">END</span> <span class="variable">IF</span><span class="operator">;</span>
      <span class="keyword">END</span><span class="operator">;</span>
      <span class="variable">FUNCTION</span> <span class="variable">from_bool</span><span class="operator">(</span> <span class="variable">i</span> <span class="variable">BOOLEAN</span> <span class="operator">)</span> <span class="variable">RETURN</span> <span class="variable">NUMBER</span> <span class="variable">IS</span>
      <span class="keyword">BEGIN</span>
         <span class="variable">IF</span>    <span class="variable">i</span> <span class="variable">IS</span> <span class="keyword">NULL</span> <span class="variable">THEN</span> <span class="variable">RETURN</span> <span class="keyword">NULL</span><span class="operator">;</span>
         <span class="variable">ELSIF</span> <span class="variable">i</span>         <span class="variable">THEN</span> <span class="variable">RETURN</span> <span class="number">1</span><span class="operator">;</span>
         <span class="variable">ELSE</span>                 <span class="variable">RETURN</span> <span class="number">0</span><span class="operator">;</span>
         <span class="keyword">END</span> <span class="variable">IF</span><span class="operator">;</span>
      <span class="keyword">END</span><span class="operator">;</span>
         <span class="keyword">BEGIN</span>
      <span class="operator">--</span> <span class="variable">Converting</span> <span class="keyword">values</span> <span class="variable">to</span> <span class="variable">BOOLEAN</span>
      <span class="variable">b0</span> <span class="operator">:=</span> <span class="variable">to_bool</span><span class="operator">(</span> <span class="operator">:</span><span class="variable">i0</span> <span class="operator">);</span>
      <span class="variable">b1</span> <span class="operator">:=</span> <span class="variable">to_bool</span><span class="operator">(</span> <span class="operator">:</span><span class="variable">i1</span> <span class="operator">);</span>
</pre>
<pre>
      <span class="operator">--</span> <span class="variable">Converting</span> <span class="keyword">values</span> <span class="variable">from</span> <span class="variable">BOOLEAN</span>
      <span class="operator">:</span><span class="variable">o0</span> <span class="operator">:=</span> <span class="variable">from_bool</span><span class="operator">(</span> <span class="variable">b0</span> <span class="operator">);</span>
      <span class="operator">:</span><span class="variable">o1</span> <span class="operator">:=</span> <span class="variable">from_bool</span><span class="operator">(</span> <span class="variable">b1</span> <span class="operator">);</span>
         <span class="keyword">END</span><span class="operator">;</span>
         <span class="variable">PLSQL_END</span>
         <span class="keyword">my</span> <span class="operator">(</span> <span class="variable">$i0</span><span class="operator">,</span> <span class="variable">$i1</span><span class="operator">,</span> <span class="variable">$o0</span><span class="operator">,</span> <span class="variable">$o1</span> <span class="operator">)</span> <span class="operator">=</span> <span class="operator">(</span> <span class="string">""</span><span class="operator">,</span> <span class="string">"Something else"</span> <span class="operator">);</span>
         <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span> <span class="string">":i0"</span><span class="operator">,</span> <span class="variable">$i0</span> <span class="operator">);</span>
         <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span> <span class="string">":i1"</span><span class="operator">,</span> <span class="variable">$i1</span> <span class="operator">);</span>
         <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span> <span class="string">":o0"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$o0</span><span class="operator">,</span> <span class="number">32</span> <span class="operator">);</span>
         <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span> <span class="string">":o1"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$o1</span><span class="operator">,</span> <span class="number">32</span> <span class="operator">);</span>
         <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">();</span>
         <span class="keyword">foreach</span> <span class="operator">(</span> <span class="variable">$i0</span><span class="operator">,</span> <span class="variable">$b0</span><span class="operator">,</span> <span class="variable">$o0</span><span class="operator">,</span> <span class="variable">$i1</span><span class="operator">,</span> <span class="variable">$b1</span><span class="operator">,</span> <span class="variable">$o1</span> <span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$_</span> <span class="operator">=</span> <span class="string">"(undef)"</span> <span class="keyword">if</span> <span class="operator">!</span> <span class="keyword">defined</span> <span class="variable">$_</span><span class="operator">;</span>
         <span class="operator">}</span>
         <span class="keyword">print</span> <span class="string">"$i0 to $o0, $i1 to $o1\n"</span><span class="operator">;</span>
         <span class="comment"># Result is : "'' to '(undef)', 'Something else' to '1'"</span>
</pre>
<p>
</p>
<hr />
<h1><a name="pl_sql_examples">PL/SQL Examples</a></h1>
<p>Most of these PL/SQL examples come from: Eric Bartley &lt;<a href="mailto:bartley@cc.purdue.edu">bartley@cc.purdue.edu</a>&gt;.</p>
<pre>
   /*
    * PL/SQL to create package with stored procedures invoked by
    * Perl examples.  Execute using sqlplus.
    *
    * Use of &quot;... OR REPLACE&quot; prevents failure in the event that the
    * package already exists.
    */</pre>
<pre>
    <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">PACKAGE</span> <span class="variable">plsql_example</span>
    <span class="variable">IS</span>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_np</span><span class="operator">;</span>
</pre>
<pre>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_in</span> <span class="operator">(</span>
          <span class="variable">err_code</span> <span class="variable">IN</span> <span class="variable">NUMBER</span>
      <span class="operator">);</span>
</pre>
<pre>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_in_inout</span> <span class="operator">(</span>
          <span class="variable">test_num</span> <span class="variable">IN</span> <span class="variable">NUMBER</span><span class="operator">,</span>
          <span class="variable">is_odd</span> <span class="variable">IN</span> <span class="variable">OUT</span> <span class="variable">NUMBER</span>
      <span class="operator">);</span>
</pre>
<pre>
      <span class="variable">FUNCTION</span> <span class="variable">func_np</span>
        <span class="variable">RETURN</span> <span class="variable">VARCHAR2</span><span class="operator">;</span>
</pre>
<pre>
    END plsql_example;
  /</pre>
<pre>
    <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">PACKAGE</span> <span class="variable">BODY</span> <span class="variable">plsql_example</span>
    <span class="variable">IS</span>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_np</span>
      <span class="variable">IS</span>
        <span class="variable">whoami</span> <span class="variable">VARCHAR2</span><span class="operator">(</span><span class="number">20</span><span class="operator">)</span> <span class="operator">:=</span> <span class="keyword">NULL</span><span class="operator">;</span>
      <span class="keyword">BEGIN</span>
        <span class="variable">SELECT</span> <span class="variable">USER</span> <span class="variable">INTO</span> <span class="variable">whoami</span> <span class="variable">FROM</span> <span class="variable">DUAL</span><span class="operator">;</span>
      <span class="keyword">END</span><span class="operator">;</span>
</pre>
<pre>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_in</span> <span class="operator">(</span>
        <span class="variable">err_code</span> <span class="variable">IN</span> <span class="variable">NUMBER</span>
      <span class="operator">)</span>
      <span class="variable">IS</span>
      <span class="keyword">BEGIN</span>
        <span class="variable">RAISE_APPLICATION_ERROR</span><span class="operator">(</span><span class="variable">err_code</span><span class="operator">,</span> <span class="string">'This is a test.'</span><span class="operator">);</span>
      <span class="keyword">END</span><span class="operator">;</span>
</pre>
<pre>
      <span class="variable">PROCEDURE</span> <span class="variable">proc_in_inout</span> <span class="operator">(</span>
        <span class="variable">test_num</span> <span class="variable">IN</span> <span class="variable">NUMBER</span><span class="operator">,</span>
        <span class="variable">is_odd</span> <span class="variable">IN</span> <span class="variable">OUT</span> <span class="variable">NUMBER</span>
      <span class="operator">)</span>
      <span class="variable">IS</span>
      <span class="keyword">BEGIN</span>
        <span class="variable">is_odd</span> <span class="operator">:=</span> <span class="variable">MOD</span><span class="operator">(</span><span class="variable">test_num</span><span class="operator">,</span> <span class="number">2</span><span class="operator">);</span>
      <span class="keyword">END</span><span class="operator">;</span>
</pre>
<pre>
      <span class="variable">FUNCTION</span> <span class="variable">func_np</span>
        <span class="variable">RETURN</span> <span class="variable">VARCHAR2</span>
      <span class="variable">IS</span>
        <span class="variable">ret_val</span> <span class="variable">VARCHAR2</span><span class="operator">(</span><span class="number">20</span><span class="operator">);</span>
      <span class="keyword">BEGIN</span>
        <span class="variable">SELECT</span> <span class="variable">USER</span> <span class="variable">INTO</span> <span class="variable">ret_val</span> <span class="variable">FROM</span> <span class="variable">DUAL</span><span class="operator">;</span>
        <span class="variable">RETURN</span> <span class="variable">ret_val</span><span class="operator">;</span>
      <span class="keyword">END</span><span class="operator">;</span>
</pre>
<pre>
    <span class="keyword">END</span> <span class="variable">plsql_example</span><span class="operator">;</span>
      <span class="regex">/
      /</span><span class="operator">*</span> <span class="variable">End</span> <span class="variable">PL</span><span class="operator">/</span><span class="variable">SQL</span> <span class="keyword">for</span> <span class="variable">example</span> <span class="keyword">package</span> <span class="variable">creation</span><span class="operator">.</span> <span class="operator">*/</span>
</pre>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
</pre>
<pre>
  <span class="keyword">my</span><span class="operator">(</span><span class="variable">$db</span><span class="operator">,</span> <span class="variable">$csr</span><span class="operator">,</span> <span class="variable">$ret_val</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$db</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(</span><span class="string">'dbi:Oracle:database'</span><span class="operator">,</span><span class="string">'user'</span><span class="operator">,</span><span class="string">'password'</span><span class="operator">)</span>
        <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"Unable to connect: $DBI::errstr"</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># So we don't have to check every DBI call we set RaiseError.</span>
  <span class="comment"># See the DBI docs now if you're not familiar with RaiseError.</span>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RaiseError</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># Example 1   Eric Bartley &lt;bartley@cc.purdue.edu&gt;</span>
  <span class="comment">#</span>
  <span class="comment"># Calling a PLSQL procedure that takes no parameters. This shows you the</span>
  <span class="comment"># basic's of what you need to execute a PLSQL procedure. Just wrap your</span>
  <span class="comment"># procedure call in a BEGIN END; block just like you'd do in SQL*Plus.</span>
  <span class="comment">#</span>
  <span class="comment"># p.s. If you've used SQL*Plus's exec command all it does is wrap the</span>
  <span class="comment">#      command in a BEGIN END; block for you.</span>
</pre>
<pre>
  <span class="variable">$csr</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
    BEGIN
      PLSQL_EXAMPLE.PROC_NP;
    END;
  }</span><span class="operator">);</span>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># Example 2   Eric Bartley &lt;bartley@cc.purdue.edu&gt;</span>
  <span class="comment">#</span>
  <span class="comment"># Now we call a procedure that has 1 IN parameter. Here we use bind_param</span>
  <span class="comment"># to bind out parameter to the prepared statement just like you might</span>
  <span class="comment"># do for an INSERT, UPDATE, DELETE, or SELECT statement.</span>
  <span class="comment">#</span>
  <span class="comment"># I could have used positional placeholders (e.g. :1, :2, etc.) or</span>
  <span class="comment"># ODBC style placeholders (e.g. ?), but I prefer Oracle's named</span>
  <span class="comment"># placeholders (but few DBI drivers support them so they're not portable).</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$err_code</span> <span class="operator">=</span> <span class="operator">-</span><span class="number">20001</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$csr</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
        BEGIN
            PLSQL_EXAMPLE.PROC_IN(:err_code);
        END;
  }</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">":err_code"</span><span class="operator">,</span> <span class="variable">$err_code</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># PROC_IN will RAISE_APPLICATION_ERROR which will cause the execute to 'fail'.</span>
  <span class="comment"># Because we set RaiseError, the DBI will croak (die) so we catch that with eval.</span>
  <span class="keyword">eval</span> <span class="operator">{</span>
    <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="operator">};</span>
  <span class="keyword">print</span> <span class="string">'After proc_in: $@='</span><span class="operator">,</span><span class="string">"'$@', errstr=$DBI::errstr, ret_val=$ret_val\n"</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># Example 3   Eric Bartley &lt;bartley@cc.purdue.edu&gt;</span>
  <span class="comment">#</span>
  <span class="comment"># Building on the last example, I've added 1 IN OUT parameter. We still</span>
  <span class="comment"># use a placeholders in the call to prepare, the difference is that</span>
  <span class="comment"># we now call bind_param_inout to bind the value to the place holder.</span>
  <span class="comment">#</span>
  <span class="comment"># Note that the third parameter to bind_param_inout is the maximum size</span>
  <span class="comment"># of the variable. You normally make this slightly larger than necessary.</span>
  <span class="comment"># But note that the perl variable will have that much memory assigned to</span>
  <span class="comment"># it even if the actual value returned is shorter.</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$test_num</span> <span class="operator">=</span> <span class="number">5</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$is_odd</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$csr</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
        BEGIN
            PLSQL_EXAMPLE.PROC_IN_INOUT(:test_num, :is_odd);
        END;
  }</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># The value of $test_num is _copied_ here</span>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">":test_num"</span><span class="operator">,</span> <span class="variable">$test_num</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":is_odd"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$is_odd</span><span class="operator">,</span> <span class="number">1</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># The execute will automagically update the value of $is_odd</span>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<pre>
  <span class="keyword">print</span> <span class="string">"$test_num is "</span><span class="operator">,</span> <span class="operator">(</span><span class="variable">$is_odd</span><span class="operator">)</span> <span class="operator">?</span> <span class="string">"odd - ok"</span> <span class="operator">:</span> <span class="string">"even - error!"</span><span class="operator">,</span> <span class="string">"\n"</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># Example 4   Eric Bartley &lt;bartley@cc.purdue.edu&gt;</span>
  <span class="comment">#</span>
  <span class="comment"># What about the return value of a PLSQL function? Well treat it the same</span>
  <span class="comment"># as you would a call to a function from SQL*Plus. We add a placeholder</span>
  <span class="comment"># for the return value and bind it with a call to bind_param_inout so</span>
  <span class="comment"># we can access it's value after execute.</span>
</pre>
<pre>
  <span class="keyword">my</span> <span class="variable">$whoami</span> <span class="operator">=</span> <span class="string">""</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$csr</span> <span class="operator">=</span> <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
        BEGIN
            :whoami := PLSQL_EXAMPLE.FUNC_NP;
        END;
  }</span><span class="operator">);</span>
</pre>
<pre>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":whoami"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$whoami</span><span class="operator">,</span> <span class="number">20</span><span class="operator">);</span>
  <span class="variable">$csr</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"Your database user name is $whoami\n"</span><span class="operator">;</span>
</pre>
<pre>
  <span class="variable">$db</span><span class="operator">-&gt;</span><span class="variable">disconnect</span><span class="operator">;</span>
</pre>
<p>You can find more examples in the t/plsql.t file in the DBD::Oracle
source directory.</p>
<p>Oracle 9.2 appears to have a bug where a variable bound
with <code>bind_param_inout()</code> that isn't assigned to by the executed
PL/SQL block may contain garbage.
See <a href="http://www.mail-archive.com/dbi-users@perl.org/msg18835.html">http://www.mail-archive.com/dbi-users@perl.org/msg18835.html</a></p>
<p>
</p>
<hr />
<h1><a name="private_database_handle_functions">Private database handle functions</a></h1>
<p>These functions are called through the method <code>func()</code>
which is described in the DBI documentation.</p>
<p>
</p>
<h2><a name="plsql_errstr">plsql_errstr</a></h2>
<p>This function returns a string which describes the errors
from the most recent PL/SQL function, procedure, package,
or package body compile in a format similar to the output
of the SQL*Plus command 'show errors'.</p>
<p>The function returns undef if the error string could not
be retrieved due to a database error.
Look in $dbh-&gt;errstr for the cause of the failure.</p>
<p>If there are no compile errors, an empty string is returned.</p>
<p>Example:</p>
<pre>
    <span class="comment"># Show the errors if CREATE PROCEDURE fails</span>
    <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RaiseError</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
    <span class="keyword">if</span> <span class="operator">(</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="keyword">do</span><span class="operator">(</span> <span class="string">q{
        CREATE OR REPLACE PROCEDURE perl_dbd_oracle_test as
        BEGIN
            PROCEDURE filltab( stuff OUT TAB ); asdf
        END; }</span> <span class="operator">)</span> <span class="operator">)</span> <span class="operator">{}</span> <span class="comment"># Statement succeeded</span>
    <span class="operator">}</span>
    <span class="keyword">elsif</span> <span class="operator">(</span> <span class="number">6550</span> <span class="operator">!=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">err</span> <span class="operator">)</span> <span class="operator">{</span> <span class="keyword">die</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">errstr</span><span class="operator">;</span> <span class="operator">}</span> <span class="comment"># Utter failure</span>
    <span class="keyword">else</span> <span class="operator">{</span>
        <span class="keyword">my</span> <span class="variable">$msg</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span> <span class="string">'plsql_errstr'</span> <span class="operator">);</span>
        <span class="keyword">die</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">errstr</span> <span class="keyword">if</span> <span class="operator">!</span> <span class="keyword">defined</span> <span class="variable">$msg</span><span class="operator">;</span>
        <span class="keyword">die</span> <span class="variable">$msg</span> <span class="keyword">if</span> <span class="variable">$msg</span><span class="operator">;</span>
    <span class="operator">}</span>
</pre>
<p>
</p>
<h2><a name="dbms_output_enable___dbms_output_put___dbms_output_get">dbms_output_enable / dbms_output_put / dbms_output_get</a></h2>
<p>These functions use the PL/SQL DBMS_OUTPUT package to store and
retrieve text using the DBMS_OUTPUT buffer.  Text stored in this buffer
by dbms_output_put or any PL/SQL block can be retrieved by
dbms_output_get or any PL/SQL block connected to the same database
session.</p>
<p>Stored text is not available until after dbms_output_put or the PL/SQL
block that saved it completes its execution.  This means you <strong>CAN NOT</strong>
use these functions to monitor long running PL/SQL procedures.</p>
<p>Example 1:</p>
<pre>
  <span class="comment"># Enable DBMS_OUTPUT and set the buffer size</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RaiseError</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span> <span class="number">1000000</span><span class="operator">,</span> <span class="string">'dbms_output_enable'</span> <span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># Put text in the buffer . . .</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span> <span class="variable">@text</span><span class="operator">,</span> <span class="string">'dbms_output_put'</span> <span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># . . . and retreive it later</span>
  <span class="variable">@text</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span> <span class="string">'dbms_output_get'</span> <span class="operator">);</span>
</pre>
<p>Example 2:</p>
<pre>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">RaiseError</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
    DECLARE tmp VARCHAR2(50);
    BEGIN
      SELECT SYSDATE INTO tmp FROM DUAL;
      dbms_output.put_line('The date is '||tmp);
    END;
  }</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<pre>
  <span class="comment"># retreive the string</span>
  <span class="variable">$date_string</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">func</span><span class="operator">(</span> <span class="string">'dbms_output_get'</span> <span class="operator">);</span>
</pre>
<dl>
<dt><strong><a name="item_dbms_output_enable">dbms_output_enable ( [ buffer_size ] )</a></strong>

<dd>
<p>This function calls DBMS_OUTPUT.ENABLE to enable calls to package
DBMS_OUTPUT procedures GET, GET_LINE, PUT, and PUT_LINE.  Calls to
these procedures are ignored unless DBMS_OUTPUT.ENABLE is called
first.</p>
</dd>
<dd>
<p>The buffer_size is the maximum amount of text that can be saved in the
buffer and must be between 2000 and 1,000,000.  If buffer_size is not
given, the default is 20,000 bytes.</p>
</dd>
</li>
<dt><strong><a name="item_dbms_output_put">dbms_output_put ( [ @lines ] )</a></strong>

<dd>
<p>This function calls DBMS_OUTPUT.PUT_LINE to add lines to the buffer.</p>
</dd>
<dd>
<p>If all lines were saved successfully the function returns 1.  Depending
on the context, an empty list or undef is returned for failure.</p>
</dd>
<dd>
<p>If any line causes buffer_size to be exceeded, a buffer overflow error
is raised and the function call fails.  Some of the text might be in
the buffer.</p>
</dd>
</li>
<dt><strong><a name="item_dbms_output_get">dbms_output_get</a></strong>

<dd>
<p>This function calls DBMS_OUTPUT.GET_LINE to retrieve lines of text from
the buffer.</p>
</dd>
<dd>
<p>In an array context, all complete lines are removed from the buffer and
returned as a list.  If there are no complete lines, an empty list is
returned.</p>
</dd>
<dd>
<p>In a scalar context, the first complete line is removed from the buffer
and returned.  If there are no complete lines, undef is returned.</p>
</dd>
<dd>
<p>Any text in the buffer after a call to DBMS_OUTPUT.GET_LINE or
DBMS_OUTPUT.GET is discarded by the next call to DBMS_OUTPUT.PUT_LINE,
DBMS_OUTPUT.PUT, or DBMS_OUTPUT.NEW_LINE.</p>
</dd>
</li>
<dt><strong><a name="item_reauthenticate">reauthenticate ( $username, $password )</a></strong>

<dd>
<p>Starts a new session against the current database using the credentials
supplied.</p>
</dd>
</li>
<dt><strong><a name="item_ora_nls_parameters">ora_nls_parameters ( [ $refresh ] )</a></strong>

<dd>
<p>Returns a hash reference containing the current NLS parameters, as given
by the v$nls_parameters view. The values fetched are cached between calls.
To cause the latest values to be fetched, pass a true value to the function.</p>
</dd>
</li>
<dt><strong><a name="item_ora_can_unicode">ora_can_unicode ( [ $refresh ] )</a></strong>

<dd>
<p>Returns a number indicating whether either of the database character sets
is a Unicode encoding. Calls <a href="#item_ora_nls_parameters"><code>ora_nls_parameters()</code></a> and passes the optional
$refresh parameter to it.</p>
</dd>
<dd>
<p>0 = Neither character set is a Unicode encoding.</p>
</dd>
<dd>
<p>1 = National character set is a Unicode encoding.</p>
</dd>
<dd>
<p>2 = Database character set is a Unicode encoding.</p>
</dd>
<dd>
<p>3 = Both character sets are Unicode encodings.</p>
</dd>
</li>
</dl>
<p>
</p>
<hr />
<h1><a name="prepare_postponed_till_execute">Prepare postponed till execute</a></h1>
<p>The DBD::Oracle module can avoid an explicit 'describe' operation
prior to the execution of the statement unless the application requests
information about the results (such as $sth-&gt;{NAME}). This reduces
communication with the server and increases performance (reducing the
number of PARSE_CALLS inside the server).</p>
<p>However, it also means that SQL errors are not detected until
<code>execute()</code> (or $sth-&gt;{NAME} etc) is called instead of when
<code>prepare()</code> is called. Note that if the describe is triggered by the
use of $sth-&gt;{NAME} or a similar attribute and the describe fails then
<em>an exception is thrown</em> even if <code>RaiseError</code> is false!</p>
<p>Set <a href="#item_ora_check_sql">ora_check_sql</a> to 0 in <code>prepare()</code> to enable this behaviour.</p>
<p>
</p>
<hr />
<h1><a name="handling_lobs">Handling LOBs</a></h1>
<p>
</p>
<h2><a name="simple_usage">Simple Usage</a></h2>
<p>The value of an Oracle LOB column is not the content of the LOB. It's a
'LOB Locator' which, after being selected or inserted needs extra
processing to read or write the content of the LOB.</p>
<p>When fetching LOBs they are, by default, made to look just like LONGs and
are subject to the LongReadLen and LongTruncOk attributes. Note that
with OCI 7 DBD::Oracle pre-allocates the whole buffer (LongReadLen) at
the time the statement is prepared.  With OCI 8+ it grows the buffer to
the amount needed for the largest LOB to be fetched so far.</p>
<p>When inserting or updating LOBs some <em>major</em> magic has to be performed
behind the scenes to make it transparent.  Basically the driver has to
insert a 'LOB Locator' and then refetch the newly inserted LOB
Locator before being able to write the data into it.  However, it works
well most of the time, and I've made it as fast as possible, just one
extra server-round-trip per insert or update after the first.  For the
time being, only single-row LOB updates are supported.</p>
<p>To insert or update a large LOB using a placeholder, DBD::Oracle has to
know in advance that it is a LOB type. So you need to say:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$field_num</span><span class="operator">,</span> <span class="variable">$lob_value</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_CLOB</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>The ORA_CLOB and ORA_BLOB constants can be imported using</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
</pre>
<p>or use the corresponding integer values (112 and 113).</p>
<p>One further wrinkle: for inserts and updates of LOBs, DBD::Oracle has
to be able to tell which parameters relate to which table fields.
In all cases where it can possibly work it out for itself, it does,
however, if there are multiple LOB fields of the same type in the table
then you need to tell it which field each LOB param relates to:</p>
<pre>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$idx</span><span class="operator">,</span> <span class="variable">$value</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span><span class="operator">=&gt;</span><span class="variable">ORA_CLOB</span><span class="operator">,</span> <span class="string">ora_field</span><span class="operator">=&gt;</span><span class="string">'foo'</span> <span class="operator">}</span><span class="operator">);</span>
</pre>
<p>There are some limitations inherent in the way DBD::Oracle makes typical
LOB operations simple by hiding the LOB Locator processing:</p>
<pre>
 - Can't read/write LOBs in chunks (except via DBMS_LOB.WRITEAPPEND in PL/SQL)
 - To INSERT a LOB, you need UPDATE privilege.</pre>
<p>The alternative is to disable the automatic LOB Locator processing.
If <a href="#item_ora_auto_lob">ora_auto_lob</a> is 0 in prepare(), you can fetch the LOB Locators and
do all the work yourself using the ora_lob_*() methods and/or Oracle::OCI.
See the <a href="#lob_methods">LOB Methods</a> section below.</p>
<p>
</p>
<h2><a name="lob_support_in_pl_sql">LOB support in PL/SQL</a></h2>
<p>LOB Locators can be passed to PL/SQL calls by binding them to placeholders
with the proper <a href="#item_ora_type"><code>ora_type</code></a>.  If <a href="#item_ora_auto_lob">ora_auto_lob</a> is true, output LOB
parameters will be automatically returned as strings.</p>
<p>If the Oracle driver has support for temporary LOBs (Oracle 9i and higher),
strings can be bound to input LOB placeholders and will be automatically 
converted to LOBs.</p>
<p>Example:
     # Build a large XML document, bind it as a CLOB,
     # extract elements through PL/SQL and return as a CLOB</p>
<pre>
     <span class="comment"># $dbh is a connected database handle </span>
     <span class="comment"># output will be large</span>
</pre>
<pre>
     <span class="keyword">local</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="operator">{</span><span class="string">LongReadLen</span><span class="operator">}</span> <span class="operator">=</span> <span class="number">1_000_000</span><span class="operator">;</span>
</pre>
<pre>
     <span class="keyword">my</span> <span class="variable">$in_clob</span> <span class="operator">=</span> <span class="string">"&lt;document&gt;\n"</span><span class="operator">;</span>
     <span class="variable">$in_clob</span> <span class="operator">.=</span> <span class="string">"  &lt;value&gt;$_&lt;/value&gt;\n"</span> <span class="keyword">for</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">10_000</span><span class="operator">;</span>
     <span class="variable">$in_clob</span> <span class="operator">.=</span> <span class="string">"&lt;/document&gt;\n"</span><span class="operator">;</span>
</pre>
<pre>
     <span class="keyword">my</span> <span class="variable">$out_clob</span><span class="operator">;</span>
     
     
     <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(&lt;&lt;</span><span class="here_document">PLSQL_END</span><span class="operator">);</span><span class="here_document">
     -- extract 'value' nodes
     DECLARE
       x XMLTYPE := XMLTYPE(:in);
     BEGIN
       :out := x.extract('/document/value').getClobVal();
     END;
     </span>
</pre>
<pre>
     PLSQL_END
     
     # :in param will be converted to a temp lob
     # :out parameter will be returned as a string.</pre>
<pre>
     <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span> <span class="string">':in'</span><span class="operator">,</span> <span class="variable">$in_clob</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_CLOB</span> <span class="operator">}</span> <span class="operator">);</span>
     <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span> <span class="string">':out'</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$out_clob</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_CLOB</span> <span class="operator">}</span> <span class="operator">);</span>
     <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<p>
</p>
<h2><a name="lob_locator_methods">LOB Locator Methods</a></h2>
<p>The following driver-specific methods let you manipulate ``LOB Locators''.
LOB locators can be selected from tables directly, if the <a href="#item_ora_auto_lob"><code>ora_auto_lob</code></a>
attribute is false, or returned via PL/SQL procedure calls.</p>
<p>(If using a DBI version earlier than 1.36 they must be called via the
<code>func()</code> method. Note that methods called via <code>func()</code> don't honour
RaiseError etc, and so it's important to check $dbh-&gt;err after each call.
It's recommended that you upgrade to DBI 1.38 or later.)</p>
<p>Note that LOB locators are only valid while the statement handle that
created them is valid.  When all references to the original statement
handle are lost, the handle is destroyed and the locators are freed.</p>
<p><strong>Warning:</strong> Currently multi-byte character set issues have not been
fully worked out.  So these methods may not do what you expect if
either the perl data is utf8 or the CLOB is a multi-byte character set
(including uft8). The current behaviour in these situations may not be
correct and is <strong>subject to change</strong>. <em>Testing and patches are most welcome.</em></p>
<dl>
<dt><strong><a name="item_ora_lob_read">ora_lob_read</a></strong>

<dd>
<pre>
  <span class="variable">$data</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_read</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$length</span><span class="operator">);</span>
</pre>
</dd>
<dd>
<p>Read a portion of the LOB. $offset starts at 1.
Uses the Oracle OCILobRead function.</p>
</dd>
<dt><strong><a name="item_ora_lob_write">ora_lob_write</a></strong>

<dd>
<pre>
  <span class="variable">$rc</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_write</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">);</span>
</pre>
</dd>
<dd>
<p>Write/overwrite a portion of the LOB. $offset starts at 1.
Uses the Oracle OCILobWrite function.</p>
</dd>
<dt><strong><a name="item_ora_lob_append">ora_lob_append</a></strong>

<dd>
<pre>
  <span class="variable">$rc</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_append</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">,</span> <span class="variable">$data</span><span class="operator">);</span>
</pre>
</dd>
<dd>
<p>Append $data to the LOB.  Uses the Oracle OCILobWriteAppend function.</p>
</dd>
<dd>
<p>NOTE: This method should <em>not</em> be used if either the client or the
server are Oracle version 8 due to Oracle bug #886191.</p>
</dd>
<dt><strong><a name="item_ora_lob_trim">ora_lob_trim</a></strong>

<dd>
<pre>
  <span class="variable">$rc</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_trim</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">,</span> <span class="variable">$length</span><span class="operator">);</span>
</pre>
</dd>
<dd>
<p>Trims the length of the LOB to $length.
Uses the Oracle OCILobTrim function.</p>
</dd>
<dt><strong><a name="item_ora_lob_length">ora_lob_length</a></strong>

<dd>
<pre>
  <span class="variable">$length</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_length</span><span class="operator">(</span><span class="variable">$lob_locator</span><span class="operator">);</span>
</pre>
</dd>
<dd>
<p>Returns the length of the LOB.
Uses the Oracle OCILobGetLength function.</p>
</dd>
</dl>
<p>
</p>
<h2><a name="lob_locator_method_examples">LOB Locator Method Examples</a></h2>
<p><em>Note:</em> Make sure you first read the note in the section above about
multi-byte character set issues with these methods.</p>
<p>The following examples demonstrate the usage of LOB Locators
to read, write, and append data, and to query the size of
large data.</p>
<p>The following examples assume a table containing two large
object columns, one binary and one character, with a primary
key column, defined as follows:</p>
<pre>
   CREATE TABLE lob_example (
      lob_id      INTEGER PRIMARY KEY,
      bindata     BLOB,
      chardata    CLOB
   )</pre>
<p>It also assumes a sequence for use in generating unique
lob_id field values, defined as follows:</p>
<pre>
   CREATE SEQUENCE lob_example_seq</pre>
<p>
</p>
<h2><a name="example__inserting_a_new_row_with_large_data">Example: Inserting a new row with large data</a></h2>
<p>Unless enough memory is available to store and bind the
entire lob data for insert all at once, the lob columns must
be written iteratively, piece by piece.  In the case of a new row,
this is performed by first inserting a row, with empty values in
the lob columns, then modifying the row by writing the large data
iteratively to the lob columns using their LOB locators as handles.</p>
<p>The insert statement must create token values in the lob
columns.  Here, we use the empty string for both the binary
and character large object columns 'bindata' and 'chardata'.</p>
<p>After the INSERT statement, a SELECT statement is used to
acquire lob locators to the 'bindata' and 'chardata' fields
of the newly inserted row.  Because these lob locators are
subsequently written, they must be acquired from a select
statement containing the clause 'FOR UPDATE' (lob locators
are only valid within the transaction that fetched them, so
can't be used effectively if AutoCommit is enabled).</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$lob_id</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">selectrow_array</span><span class="operator">( &lt;&lt;</span><span class="here_document">"   SQL"</span> <span class="operator">);</span><span class="here_document">
      SELECT lob_example_seq.nextval FROM DUAL
   SQL
   </span>
</pre>
<pre>
   <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">( &lt;&lt;</span><span class="here_document">"   SQL"</span> <span class="operator">);</span><span class="here_document">
      INSERT INTO lob_example
      ( lob_id, bindata, chardata )
      VALUES ( ?, EMPTY_BLOB(),EMPTY_CLOB() )
   SQL
   $sth-&gt;execute( $lob_id );
   </span>
</pre>
<pre>
   <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">( &lt;&lt;</span><span class="here_document">"   SQL"</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_auto_lob</span> <span class="operator">=&gt;</span> <span class="number">0</span> <span class="operator">}</span> <span class="operator">);</span><span class="here_document">
      SELECT bindata, chardata
      FROM lob_example
      WHERE lob_id = ?
      FOR UPDATE
   SQL
   $sth-&gt;execute( $lob_id );
   my ( $bin_locator, $char_locator ) = $sth-&gt;fetchrow_array();
   $sth-&gt;finish();
   </span>
</pre>
<pre>
   <span class="keyword">open</span> <span class="variable">BIN_FH</span><span class="operator">,</span> <span class="string">"/binary/data/source"</span> <span class="keyword">or</span> <span class="keyword">die</span><span class="operator">;</span>
   <span class="keyword">open</span> <span class="variable">CHAR_FH</span><span class="operator">,</span> <span class="string">"/character/data/source"</span> <span class="keyword">or</span> <span class="keyword">die</span><span class="operator">;</span>
   <span class="keyword">my</span> <span class="variable">$chunk_size</span> <span class="operator">=</span> <span class="number">4096</span><span class="operator">;</span>   <span class="comment"># Arbitrary chunk size</span>
</pre>
<pre>
   <span class="comment"># BEGIN WRITING BIN_DATA COLUMN</span>
   <span class="keyword">my</span> <span class="variable">$offset</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>   <span class="comment"># Offsets start at 1, not 0</span>
   <span class="keyword">my</span> <span class="variable">$length</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
   <span class="keyword">my</span> <span class="variable">$buffer</span> <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
   <span class="keyword">while</span><span class="operator">(</span> <span class="variable">$length</span> <span class="operator">=</span> <span class="keyword">read</span><span class="operator">(</span> <span class="variable">BIN_FH</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="variable">$chunk_size</span> <span class="operator">)</span> <span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_write</span><span class="operator">(</span> <span class="variable">$bin_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$buffer</span> <span class="operator">);</span>
      <span class="variable">$offset</span> <span class="operator">+=</span> <span class="variable">$length</span><span class="operator">;</span>
   <span class="operator">}</span>
</pre>
<pre>
   <span class="comment"># BEGIN WRITING CHAR_DATA COLUMN</span>
   <span class="variable">$offset</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>   <span class="comment"># Offsets start at 1, not 0</span>
   <span class="variable">$length</span> <span class="operator">=</span> <span class="number">0</span><span class="operator">;</span>
   <span class="variable">$buffer</span> <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
   <span class="keyword">while</span><span class="operator">(</span> <span class="variable">$length</span> <span class="operator">=</span> <span class="keyword">read</span><span class="operator">(</span> <span class="variable">CHAR_FH</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="variable">$chunk_size</span> <span class="operator">)</span> <span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_write</span><span class="operator">(</span> <span class="variable">$char_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$buffer</span> <span class="operator">);</span>
      <span class="variable">$offset</span> <span class="operator">+=</span> <span class="variable">$length</span><span class="operator">;</span>
   <span class="operator">}</span>
</pre>
<p>In this example we demonstrate the use of <a href="#item_ora_lob_write"><code>ora_lob_write()</code></a>
iteratively to append data to the columns 'bin_data' and
'char_data'.  Had we used ora_lob_append(), we could have
saved ourselves the trouble of keeping track of the offset
into the lobs.  The snippet of code beneath the comment
'BEGIN WRITING BIN_DATA COLUMN' could look as follows:</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$buffer</span> <span class="operator">=</span> <span class="string">''</span><span class="operator">;</span>
   <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">read</span><span class="operator">(</span> <span class="variable">BIN_FH</span><span class="operator">,</span> <span class="variable">$buffer</span><span class="operator">,</span> <span class="variable">$chunk_size</span> <span class="operator">)</span> <span class="operator">)</span> <span class="operator">{</span>
      <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_append</span><span class="operator">(</span> <span class="variable">$bin_locator</span><span class="operator">,</span> <span class="variable">$buffer</span> <span class="operator">);</span>
   <span class="operator">}</span>
</pre>
<p>The scalar variables $offset and $length are no longer
needed, because <a href="#item_ora_lob_append"><code>ora_lob_append()</code></a> keeps track of the offset
for us.</p>
<p>
</p>
<h2><a name="example__updating_an_existing_row_with_large_data">Example: Updating an existing row with large data</a></h2>
<p>In this example, we demonstrate a technique for overwriting
a portion of a blob field with new binary data.  The blob
data before and after the section overwritten remains
unchanged.  Hence, this technique could be used for updating
fixed length subfields embedded in a binary field.</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$lob_id</span> <span class="operator">=</span> <span class="number">5</span><span class="operator">;</span>   <span class="comment"># Arbitrary row identifier, for example</span>
</pre>
<pre>
   <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">( &lt;&lt;</span><span class="here_document">"   SQL"</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_auto_lob</span> <span class="operator">=&gt;</span> <span class="number">0</span> <span class="operator">}</span> <span class="operator">);</span><span class="here_document">
      SELECT bindata
      FROM lob_example
      WHERE lob_id = ?
      FOR UPDATE
   SQL
   $sth-&gt;execute( $lob_id );
   my ( $bin_locator ) = $sth-&gt;fetchrow_array();
   </span>
</pre>
<pre>
   <span class="keyword">my</span> <span class="variable">$offset</span> <span class="operator">=</span> <span class="number">100234</span><span class="operator">;</span>
   <span class="keyword">my</span> <span class="variable">$data</span> <span class="operator">=</span> <span class="string">"This string will overwrite a portion of the blob"</span><span class="operator">;</span>
   <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_write</span><span class="operator">(</span> <span class="variable">$bin_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$data</span> <span class="operator">);</span>
</pre>
<p>After running this code, the row where lob_id = 5 will
contain, starting at position 100234 in the bin_data column,
the string ``This string will overwrite a portion of the blob''.</p>
<p>
</p>
<h2><a name="example__streaming_character_data_from_the_database">Example: Streaming character data from the database</a></h2>
<p>In this example, we demonstrate a technique for streaming
data from the database to a file handle, in this case
STDOUT.  This allows more data to be read in and written out
than could be stored in memory at a given time.</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$lob_id</span> <span class="operator">=</span> <span class="number">17</span><span class="operator">;</span>   <span class="comment"># Arbitrary row identifier, for example</span>
</pre>
<pre>
   <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">( &lt;&lt;</span><span class="here_document">"   SQL"</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_auto_lob</span> <span class="operator">=&gt;</span> <span class="number">0</span> <span class="operator">}</span> <span class="operator">);</span><span class="here_document">
      SELECT chardata
      FROM lob_example
      WHERE lob_id = ?
   SQL
   $sth-&gt;execute( $lob_id );
   my ( $char_locator ) = $sth-&gt;fetchrow_array();
   </span>
</pre>
<pre>
   <span class="keyword">my</span> <span class="variable">$chunk_size</span> <span class="operator">=</span> <span class="number">1034</span><span class="operator">;</span>   <span class="comment"># Arbitrary chunk size, for example</span>
   <span class="keyword">my</span> <span class="variable">$offset</span> <span class="operator">=</span> <span class="number">1</span><span class="operator">;</span>   <span class="comment"># Offsets start at 1, not 0</span>
   <span class="keyword">while</span><span class="operator">(</span> <span class="keyword">my</span> <span class="variable">$data</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">ora_lob_read</span><span class="operator">(</span> <span class="variable">$char_locator</span><span class="operator">,</span> <span class="variable">$offset</span><span class="operator">,</span> <span class="variable">$chunk_size</span> <span class="operator">)</span> <span class="operator">)</span> <span class="operator">{</span>
      <span class="keyword">print</span> <span class="variable">STDOUT</span> <span class="variable">$data</span><span class="operator">;</span>
      <span class="variable">$offset</span> <span class="operator">+=</span> <span class="variable">$chunk_size</span><span class="operator">;</span>
   <span class="operator">}</span>
</pre>
<p>Notice that the select statement does not contain the phrase
``FOR UPDATE''.  Because we are only reading from the lob
locator returned, and not modifying the lob it refers to,
the select statement does not require the ``FOR UPDATE''
clause.</p>
<p>
</p>
<h2><a name="example__truncating_existing_large_data">Example: Truncating existing large data</a></h2>
<p>In this example, we truncate the data already present in a
large object column in the database.  Specifically, for each
row in the table, we truncate the 'bindata' value to half
its previous length.</p>
<p>After acquiring a lob locator for the column, we query its
length, then we trim the length by half.  Because we modify
the large objects with the call to ora_lob_trim(), we must
select the lob locators 'FOR UPDATE'.</p>
<pre>
   <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">( &lt;&lt;</span><span class="here_document">"   SQL"</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_auto_lob</span> <span class="operator">=&gt;</span> <span class="number">0</span> <span class="operator">}</span> <span class="operator">);</span><span class="here_document">
      SELECT bindata
      FROM lob_example
      FOR UPATE
   SQL
   $sth-&gt;execute();
   while( my ( $bin_locator ) = $sth-&gt;fetchrow_array() ) {
      my $binlength = $dbh-&gt;ora_lob_length( $bin_locator );
      if( $binlength &gt; 0 ) {
         $dbh-&gt;ora_lob_trim( $bin_locator, $binlength/2 );
      }
   }
   </span>
</pre>
<p>
</p>
<hr />
<h1><a name="binding_cursors">Binding Cursors</a></h1>
<p>Cursors can be returned from PL/SQL blocks, either from stored
functions (or procedures with OUT parameters) or
from direct <code>OPEN</code> statements, as shown below:</p>
<pre>
  <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
  <span class="keyword">use</span> <span class="variable">DBD::Oracle</span> <span class="string">qw(:ora_types)</span><span class="operator">;</span>
  <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(...);</span>
  <span class="keyword">my</span> <span class="variable">$sth1</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
      BEGIN OPEN :cursor FOR
          SELECT table_name, tablespace_name
          FROM user_tables WHERE tablespace_name = :space;
      END;
  }</span><span class="operator">);</span>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">":space"</span><span class="operator">,</span> <span class="string">"USERS"</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$sth2</span><span class="operator">;</span>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":cursor"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$sth2</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_RSET</span> <span class="operator">}</span> <span class="operator">);</span>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="comment"># $sth2 is now a valid DBI statement handle for the cursor</span>
  <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="variable">@row</span> <span class="operator">=</span> <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">)</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
</pre>
<p>The only special requirement is the use of <code>bind_param_inout()</code> with an
attribute hash parameter that specifies <a href="#item_ora_type"><code>ora_type</code></a> as <code>ORA_RSET</code>.
If you don't do that you'll get an error from the <code>execute()</code> like:
``ORA-06550: line X, column Y: PLS-00306: wrong number or types of
arguments in call to ...''.</p>
<p>Here's an alternative form using a function that returns a cursor.
This example uses the pre-defined weak (or generic) REF CURSOR type
SYS_REFCURSOR. This is an Oracle 9 feature. For Oracle 8, you must
create your own REF CURSOR type in a package (see the <code>curref.pl</code>
script mentioned at the end of this section).</p>
<pre>
  <span class="comment"># Create the function that returns a cursor</span>
  <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="keyword">do</span><span class="operator">(</span><span class="string">q{
      CREATE OR REPLACE FUNCTION sp_ListEmp RETURN SYS_REFCURSOR
      AS l_cursor SYS_REFCURSOR;
      BEGIN
          OPEN l_cursor FOR select ename, empno from emp
              ORDER BY ename;
          RETURN l_cursor;
      END;
  }</span><span class="operator">);</span>
</pre>
<pre>
  <span class="comment"># Use the function that returns a cursor</span>
  <span class="keyword">my</span> <span class="variable">$sth1</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{BEGIN :cursor := sp_ListEmp; END;}</span><span class="operator">);</span>
  <span class="keyword">my</span> <span class="variable">$sth2</span><span class="operator">;</span>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":cursor"</span><span class="operator">,</span> <span class="operator">\</span><span class="variable">$sth2</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_RSET</span> <span class="operator">}</span> <span class="operator">);</span>
  <span class="variable">$sth1</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="comment"># $sth2 is now a valid DBI statement handle for the cursor</span>
  <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="variable">@row</span> <span class="operator">=</span> <span class="variable">$sth2</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">)</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
</pre>
<p>A cursor obtained from PL/SQL as above may be passed back to PL/SQL
by binding for input, as shown in this example, which explicitly
closes a cursor:</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$sth3</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">"BEGIN CLOSE :cursor; END;"</span><span class="operator">);</span>
  <span class="variable">$sth3</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">":cursor"</span><span class="operator">,</span> <span class="variable">$sth2</span><span class="operator">,</span> <span class="operator">{</span> <span class="string">ora_type</span> <span class="operator">=&gt;</span> <span class="variable">ORA_RSET</span> <span class="operator">}</span> <span class="operator">);</span>
  <span class="variable">$sth3</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<p>It is not normally necessary to close a cursor
explicitly in this way. Oracle will close the cursor automatically
at the first client-server interaction after the cursor statement handle is
destroyed. An explicit close may be desirable if the reference to
the cursor handle from the PL/SQL statement handle delays the destruction
of the cursor handle for too long. This reference remains until the
PL/SQL handle is re-bound, re-executed or destroyed.</p>
<p>See the <code>curref.pl</code> script in the Oracle.ex directory in the DBD::Oracle
source distribution for a complete working example.</p>
<p>
</p>
<hr />
<h1><a name="fetching_nested_cursors">Fetching Nested Cursors</a></h1>
<p>Oracle supports the use of select list expressions of type REF CURSOR.
These may be explicit cursor expressions - <code>CURSOR(SELECT ...)</code>, or
calls to PL/SQL functions which return REF CURSOR values. The values
of these expressions are known as nested cursors.</p>
<p>The value returned to a Perl program when a nested cursor is fetched
is a statement handle. This statement handle is ready to be fetched from.
It should not (indeed, must not) be executed.</p>
<p>Oracle imposes a restriction on the order of fetching when nested
cursors are used. Suppose <code>$sth1</code> is a handle for a select statement
involving nested cursors, and <code>$sth2</code> is a nested cursor handle fetched
from <code>$sth1</code>. <code>$sth2</code> can only be fetched from while <code>$sth1</code> is
still active, and the row containing <code>$sth2</code> is still current in <code>$sth1</code>.
Any attempt to fetch another row from <code>$sth1</code> renders all nested cursor
handles previously fetched from <code>$sth1</code> defunct.</p>
<p>Fetching from such a defunct handle results in an error with the message
<code>ERROR nested cursor is defunct (parent row is no longer current)</code>.</p>
<p>This means that the <code>fetchall...</code> or <code>selectall...</code> methods are not useful
for queries returning nested cursors. By the time such a method returns,
all the nested cursor handles it has fetched will be defunct.</p>
<p>It is necessary to use an explicit fetch loop, and to do all the
fetching of nested cursors within the loop, as the following example
shows:</p>
<pre>
    <span class="keyword">use</span> <span class="variable">DBI</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="variable">$dbh</span> <span class="operator">=</span> <span class="variable">DBI</span><span class="operator">-&gt;</span><span class="keyword">connect</span><span class="operator">(...);</span>
    <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{
        SELECT dname, CURSOR(
            SELECT ename FROM emp
                WHERE emp.deptno = dept.deptno
                ORDER BY ename
        ) FROM dept ORDER BY dname
    }</span><span class="operator">);</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
    <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$dname</span><span class="operator">,</span> <span class="variable">$nested</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">)</span> <span class="operator">{</span>
        <span class="keyword">print</span> <span class="string">"$dname\n"</span><span class="operator">;</span>
        <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$ename</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$nested</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">)</span> <span class="operator">{</span>
            <span class="keyword">print</span> <span class="string">"        $ename\n"</span><span class="operator">;</span>
        <span class="operator">}</span>
    <span class="operator">}</span>
</pre>
<p>The cursor returned by the function <code>sp_ListEmp</code> defined in the
previous section can be fetched as a nested cursor as follows:</p>
<pre>
    <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">q{SELECT sp_ListEmp FROM dual}</span><span class="operator">);</span>
    <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
    <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$nested</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span><span class="operator">;</span>
    <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="variable">@row</span> <span class="operator">=</span> <span class="variable">$nested</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">)</span> <span class="operator">{</span> <span class="operator">...</span> <span class="operator">}</span>
</pre>
<p>
</p>
<h2><a name="prefetching_nested_cursors">Pre-fetching Nested Cursors</a></h2>
<p>By default, DBD::Oracle pre-fetches rows in order to reduce the number of
round trips to the server. For queries which do not involve nested cursors,
the number of pre-fetched rows is controlled by the DBI database handle
attribute <code>RowCacheSize</code> (q.v.).</p>
<p>In Oracle, server side open cursors are a controlled resource, limited in
number, on a per session basis, to the value of the initialization
parameter <code>OPEN_CURSORS</code>. Nested cursors count towards ths limit.
Each nested cursor in the current row counts 1, as does
each nested cursor in a pre-fetched row. Defunct nested cursors do not count.</p>
<p>An Oracle specific database handle attribute, <code>ora_max_nested_cursors</code>,
further controls pre-fetching for queries involving nested cursors. For
each statement handle, the total number of nested cursors in pre-fetched
rows is limited to the value of this parameter. The default value
is 0, which disables pre-fetching for queries involving nested cursors.</p>
<p>
</p>
<hr />
<h1><a name="returning_a_value_from_an_insert">Returning A Value from an INSERT</a></h1>
<p>Oracle supports an extended SQL insert syntax which will return one
or more of the values inserted. This can be particularly useful for
single-pass insertion of values with re-used sequence values
(avoiding a separate ``select seq.nextval from dual'' step).</p>
<pre>
  <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">qq{
      INSERT INTO foo (id, bar)
      VALUES (foo_id_seq.nextval, :bar)
      RETURNING id INTO :id
  }</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="string">":bar"</span><span class="operator">,</span> <span class="number">42</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="string">":id"</span><span class="operator">,</span> <span class="operator">\</span><span class="keyword">my</span> <span class="variable">$new_id</span><span class="operator">,</span> <span class="number">99</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="keyword">print</span> <span class="string">"The id of the new record is $new_id\n"</span><span class="operator">;</span>
</pre>
<p>If you have many columns to bind you can use code like this:</p>
<pre>
  <span class="variable">@params</span> <span class="operator">=</span> <span class="operator">(...</span> <span class="variable">column</span> <span class="keyword">values</span> <span class="keyword">for</span> <span class="variable">record</span> <span class="variable">to</span> <span class="variable">be</span> <span class="variable">inserted</span> <span class="operator">...);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param</span><span class="operator">(</span><span class="variable">$_</span><span class="operator">,</span> <span class="variable">$params</span><span class="operator">[</span><span class="variable">$_</span><span class="operator">-</span><span class="number">1</span><span class="operator">]</span><span class="operator">)</span> <span class="keyword">for</span> <span class="operator">(</span><span class="number">1</span><span class="operator">..</span><span class="variable">@params</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">bind_param_inout</span><span class="operator">(</span><span class="variable">@params</span><span class="operator">+</span><span class="number">1</span><span class="operator">,</span> <span class="operator">\</span><span class="keyword">my</span> <span class="variable">$new_id</span><span class="operator">,</span> <span class="number">99</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
</pre>
<p>
</p>
<hr />
<h1><a name="returning_a_recordset">Returning A Recordset</a></h1>
<p>DBD::Oracle does not currently support binding a PL/SQL table (aka array)
as an IN OUT parameter to any Perl data structure.  You cannot therefore call
a PL/SQL function or procedure from DBI that uses a non-atomic data type as
either a parameter, or a return value.  However, if you are using Oracle 9.0.1
or later, you can make use of table (or pipelined) functions.</p>
<p>For example, assume you have the existing PL/SQL Package :</p>
<p>CREATE OR REPLACE PACKAGE Array_Example AS
    --
    TYPE tRec IS RECORD (
        Col1    NUMBER,
        Col2    VARCHAR2 (10),
        Col3    DATE) ;
    --
    TYPE taRec IS TABLE OF tRec INDEX BY BINARY_INTEGER ;
    --
    FUNCTION Array_Func RETURN taRec ;
    --
END Array_Example ;</p>
<p>CREATE OR REPLACE PACKAGE BODY Array_Example AS
--
FUNCTION Array_Func RETURN taRec AS
--
    l_Ret       taRec ;
--
BEGIN
    FOR i IN 1 .. 5 LOOP
        l_Ret (i).Col1 := i ;
        l_Ret (i).Col2 := 'Row : ' || i ;
        l_Ret (i).Col3 := TRUNC (SYSDATE) + i ;
    END LOOP ;
    RETURN l_Ret ;
END ;
--
END Array_Example ;
/</p>
<p>Currently, there is no way to directly call the function
Array_Example.Array_Func from DBI.  However, by making the following relatively
painless additions, its not only possible, but extremely efficient.</p>
<p>First, you need to create database object types that correspond to the record
and table types in the package.  From the above example, these would be :</p>
<pre>
  <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">TYPE</span> <span class="variable">tArray_Example__taRec</span>
  <span class="variable">AS</span> <span class="variable">OBJECT</span> <span class="operator">(</span>
      <span class="variable">Col1</span>    <span class="variable">NUMBER</span><span class="operator">,</span>
      <span class="variable">Col2</span>    <span class="variable">VARCHAR2</span> <span class="operator">(</span><span class="number">10</span><span class="operator">),</span>
      <span class="variable">Col3</span>    <span class="variable">DATE</span>
  <span class="operator">)</span> <span class="operator">;</span>
</pre>
<pre>
  <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">TYPE</span> <span class="variable">taArray_Example__taRec</span>
  <span class="variable">AS</span> <span class="variable">TABLE</span> <span class="variable">OF</span> <span class="variable">tArray_Example__taRec</span> <span class="operator">;</span>
</pre>
<p>Now, assuming the existing function needs to remain unchanged (it is probably
being called from other PL/SQL code), we need to add a new function to the
package.  Here's the new package specification and body :</p>
<pre>
  <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">PACKAGE</span> <span class="variable">Array_Example</span> <span class="variable">AS</span>
      <span class="operator">--</span>
      <span class="variable">TYPE</span> <span class="variable">tRec</span> <span class="variable">IS</span> <span class="variable">RECORD</span> <span class="operator">(</span>
          <span class="variable">Col1</span>    <span class="variable">NUMBER</span><span class="operator">,</span>
          <span class="variable">Col2</span>    <span class="variable">VARCHAR2</span> <span class="operator">(</span><span class="number">10</span><span class="operator">),</span>
          <span class="variable">Col3</span>    <span class="variable">DATE</span><span class="operator">)</span> <span class="operator">;</span>
      <span class="operator">--</span>
      <span class="variable">TYPE</span> <span class="variable">taRec</span> <span class="variable">IS</span> <span class="variable">TABLE</span> <span class="variable">OF</span> <span class="variable">tRec</span> <span class="variable">INDEX</span> <span class="variable">BY</span> <span class="variable">BINARY_INTEGER</span> <span class="operator">;</span>
      <span class="operator">--</span>
      <span class="variable">FUNCTION</span> <span class="variable">Array_Func</span> <span class="variable">RETURN</span> <span class="variable">taRec</span> <span class="operator">;</span>
      <span class="variable">FUNCTION</span> <span class="variable">Array_Func_DBI</span> <span class="variable">RETURN</span> <span class="variable">taArray_Example__taRec</span> <span class="variable">PIPELINED</span> <span class="operator">;</span>
      <span class="operator">--</span>
  <span class="keyword">END</span> <span class="variable">Array_Example</span> <span class="operator">;</span>
</pre>
<pre>
  <span class="variable">CREATE</span> <span class="variable">OR</span> <span class="variable">REPLACE</span> <span class="variable">PACKAGE</span> <span class="variable">BODY</span> <span class="variable">Array_Example</span> <span class="variable">AS</span>
  <span class="operator">--</span>
  <span class="variable">FUNCTION</span> <span class="variable">Array_Func</span> <span class="variable">RETURN</span> <span class="variable">taRec</span> <span class="variable">AS</span>
      <span class="variable">l_Ret</span>  <span class="variable">taRec</span> <span class="operator">;</span>
  <span class="keyword">BEGIN</span>
      <span class="variable">FOR</span> <span class="variable">i</span> <span class="variable">IN</span> <span class="number">1</span> <span class="operator">..</span> <span class="number">5</span> <span class="variable">LOOP</span>
          <span class="variable">l_Ret</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col1</span> <span class="operator">:=</span> <span class="variable">i</span> <span class="operator">;</span>
          <span class="variable">l_Ret</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col2</span> <span class="operator">:=</span> <span class="string">'Row : '</span> <span class="operator">||</span> <span class="variable">i</span> <span class="operator">;</span>
          <span class="variable">l_Ret</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col3</span> <span class="operator">:=</span> <span class="variable">TRUNC</span> <span class="operator">(</span><span class="variable">SYSDATE</span><span class="operator">)</span> <span class="operator">+</span> <span class="variable">i</span> <span class="operator">;</span>
      <span class="keyword">END</span> <span class="variable">LOOP</span> <span class="operator">;</span>
      <span class="variable">RETURN</span> <span class="variable">l_Ret</span> <span class="operator">;</span>
  <span class="keyword">END</span> <span class="operator">;</span>
</pre>
<pre>
  <span class="variable">FUNCTION</span> <span class="variable">Array_Func_DBI</span> <span class="variable">RETURN</span> <span class="variable">taArray_Example__taRec</span> <span class="variable">PIPELINED</span> <span class="variable">AS</span>
      <span class="variable">l_Set</span>  <span class="variable">taRec</span> <span class="operator">;</span>
  <span class="keyword">BEGIN</span>
      <span class="variable">l_Set</span> <span class="operator">:=</span> <span class="variable">Array_Func</span> <span class="operator">;</span>
      <span class="variable">FOR</span> <span class="variable">i</span> <span class="variable">IN</span> <span class="variable">l_Set</span><span class="operator">.</span><span class="variable">FIRST</span> <span class="operator">..</span> <span class="variable">l_Set</span><span class="operator">.</span><span class="variable">LAST</span> <span class="variable">LOOP</span>
          <span class="variable">PIPE</span> <span class="variable">ROW</span> <span class="operator">(</span>
              <span class="variable">tArray_Example__taRec</span> <span class="operator">(</span>
                  <span class="variable">l_Set</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col1</span><span class="operator">,</span>
                  <span class="variable">l_Set</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col2</span><span class="operator">,</span>
                  <span class="variable">l_Set</span> <span class="operator">(</span><span class="variable">i</span><span class="operator">).</span><span class="variable">Col3</span>
              <span class="operator">)</span>
          <span class="operator">)</span> <span class="operator">;</span>
      <span class="keyword">END</span> <span class="variable">LOOP</span> <span class="operator">;</span>
      <span class="variable">RETURN</span> <span class="operator">;</span>
  <span class="keyword">END</span> <span class="operator">;</span>
  <span class="operator">--</span>
  <span class="keyword">END</span> <span class="variable">Array_Example</span> <span class="operator">;</span>
</pre>
<p>As you can see, the new function is very simple.  Now, it is a simple matter
of calling the function as a straight-forward SELECT from your DBI code.  From
the above example, the code would look something like this :</p>
<pre>
  <span class="keyword">my</span> <span class="variable">$sth</span> <span class="operator">=</span> <span class="variable">$dbh</span><span class="operator">-&gt;</span><span class="variable">prepare</span><span class="operator">(</span><span class="string">'SELECT * FROM TABLE(Array_Example.Array_Func_DBI)'</span><span class="operator">);</span>
  <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">execute</span><span class="operator">;</span>
  <span class="keyword">while</span> <span class="operator">(</span> <span class="keyword">my</span> <span class="operator">(</span><span class="variable">$col1</span><span class="operator">,</span> <span class="variable">$col2</span><span class="operator">,</span> <span class="variable">$col3</span><span class="operator">)</span> <span class="operator">=</span> <span class="variable">$sth</span><span class="operator">-&gt;</span><span class="variable">fetchrow_array</span> <span class="operator">{</span>
    <span class="operator">...</span>
  <span class="operator">}</span>
</pre>
<p>
</p>
<hr />
<h1><a name="timezones">Timezones</a></h1>
<p>If TWO_TASK isn't set, Oracle uses the TZ variable from the local environment.
</p>
<pre>

If TWO_TASK IS set, Oracle uses the TZ variable of the listener process
running on the server.</pre>
<p>You could have multiple listeners, each with their own TZ, and assign
users to the appropriate listener by setting TNS_ADMIN to a directory
that contains a tnsnames.ora file that points to the port that their
listener is on.</p>
<p>[Brad Howerter, who supplied this info said: ``I've done this to simulate
running a perl script at the end of the previous month even though it
was the 6th of the new month.  I had the dba start up a listener with
TZ=X+144.  (144 hours = 6 days)'']</p>
<p>
</p>
<hr />
<h1><a name="oracle_related_links">Oracle Related Links</a></h1>
<p>
</p>
<h2><a name="oracle_on_linux">Oracle on Linux</a></h2>
<pre>
  <a href="http://www.datamgmt.com/maillist.html">http://www.datamgmt.com/maillist.html</a>
  <a href="http://www.eGroups.com/list/oracle-on-linux">http://www.eGroups.com/list/oracle-on-linux</a>
  <a href="http://www.wmd.de/wmd/staff/pauck/misc/oracle_on_linux.html">http://www.wmd.de/wmd/staff/pauck/misc/oracle_on_linux.html</a>
  <a href="ftp://oracle-ftp.oracle.com/server/patch_sets/LINUX">ftp://oracle-ftp.oracle.com/server/patch_sets/LINUX</a>
  <a href="http://www.ixora.com.au/">http://www.ixora.com.au/</a></pre>
<p>
</p>
<h2><a name="free_oracle_tools_and_links">Free Oracle Tools and Links</a></h2>
<pre>
  ora_explain supplied and installed with DBD::Oracle.</pre>
<pre>
  <a href="http://www.orafaq.com/">http://www.orafaq.com/</a></pre>
<pre>
  <a href="http://vonnieda.org/oracletool/">http://vonnieda.org/oracletool/</a></pre>
<p>
</p>
<h2><a name="commercial_oracle_tools_and_links">Commercial Oracle Tools and Links</a></h2>
<p>Assorted tools and references for general information.
No recommendation implied.</p>
<pre>
  <a href="http://www.platinum.com/products/oracle.htm">http://www.platinum.com/products/oracle.htm</a>
  <a href="http://www.SoftTreeTech.com">http://www.SoftTreeTech.com</a>
  <a href="http://www.databasegroup.com">http://www.databasegroup.com</a></pre>
<p>Also PL/Vision from RevealNet and Steven Feuerstein, and
``Q'' from Savant Corporation.</p>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="../../../site/lib/DBI.html">the DBI manpage</a></p>
<p><a href="http://search.cpan.org/~timb/DBD-Oracle/MANIFEST">http://search.cpan.org/~timb/DBD-Oracle/MANIFEST</a> for all files in
the DBD::Oracle source distribution including the examples in the
Oracle.ex directory</p>
<pre>
  <a href="http://search.cpan.org/search?query=Oracle&amp;mode=dist">http://search.cpan.org/search?query=Oracle&amp;mode=dist</a></pre>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>DBD::Oracle by Tim Bunce. DBI by Tim Bunce.</p>
<p>
</p>
<hr />
<h1><a name="acknowledgements">ACKNOWLEDGEMENTS</a></h1>
<p>A great many people have helped me with DBD::Oracle over the 12 years
between 1994 and 2006.  Far too many to name, but I thank them all.
Many are named in the Changes file.</p>
<p>See also <a href="../../../site/lib/DBI/acknowledgements.html">ACKNOWLEDGEMENTS in the DBI manpage</a>.</p>
<p>
</p>
<hr />
<h1><a name="maintainer">MAINTAINER</a></h1>
<p>As of release 1.17 in February 2006 The Pythian Group, Inc. (<a href="http://www.pythian.com">http://www.pythian.com</a>)
are taking the lead in maintaining DBD::Oracle with my assistance and
gratitude. That frees more of my time to work on DBI for perl 5 and perl 6.</p>
<p>
</p>
<hr />
<h1><a name="copyright">COPYRIGHT</a></h1>
<p>The DBD::Oracle module is Copyright (c) 1994-2006 Tim Bunce. Ireland.</p>
<p>The DBD::Oracle module is free open source software; you can
redistribute it and/or modify it under the same terms as Perl 5.</p>
<p>
</p>
<hr />
<h1><a name="contributing">CONTRIBUTING</a></h1>
<p>If you'd like DBD::Oracle to do something new or different the best way
to make that happen is to do it yourself and email to <a href="mailto:dbi-dev@perl.org">dbi-dev@perl.org</a> a
patch of the source code (using 'diff' - see below) that shows the changes.</p>
<p>
</p>
<h2><a name="how_to_create_a_patch_using_subversion">How to create a patch using Subversion</a></h2>
<p>The DBD::Oracle source code is maintained using Subversion (a replacement
for CVS, see <a href="http://subversion.tigris.org/">http://subversion.tigris.org/</a>). To access the source
you'll need to install a Subversion client. Then, to get the source
code, do:</p>
<pre>
  svn checkout <a href="http://svn.perl.org/modules/dbd-oracle/trunk">http://svn.perl.org/modules/dbd-oracle/trunk</a></pre>
<p>If it prompts for a username and password use your perl.org account
if you have one, else just 'guest' and 'guest'. The source code will
be in a new subdirectory called <code>trunk</code>.</p>
<p>To keep informed about changes to the source you can send an empty email
to <a href="mailto:dbd-oracle-changes-subscribe@perl.org">dbd-oracle-changes-subscribe@perl.org</a> after which you'll get an email with the
change log message and diff of each change checked-in to the source.</p>
<p>After making your changes you can generate a patch file, but before
you do, make sure your source is still upto date using:</p>
<pre>
  svn update</pre>
<p>If you get any conflicts reported you'll need to fix them first.
Then generate the patch file from within the <code>trunk</code> directory using:</p>
<pre>
  svn diff &gt; foo.patch</pre>
<p>Read the patch file, as a sanity check, and then email it to <a href="mailto:dbi-dev@perl.org.">dbi-dev@perl.org.</a></p>
<p>
</p>
<h2><a name="how_to_create_a_patch_without_subversion">How to create a patch without Subversion</a></h2>
<p>Unpack a fresh copy of the distribution:</p>
<pre>
  tar xfz DBD-Oracle-1.40.tar.gz</pre>
<p>Rename the newly created top level directory:</p>
<pre>
  mv DBD-Oracle-1.40 DBD-Oracle-1.40.your_foo</pre>
<p>Edit the contents of DBD-Oracle-1.40.your_foo/* till it does what you want.</p>
<p>Test your changes and then remove all temporary files:</p>
<pre>
  make test &amp;&amp; make distclean</pre>
<p>Go back to the directory you originally unpacked the distribution:</p>
<pre>
  cd ..</pre>
<p>Unpack <em>another</em> copy of the original distribution you started with:</p>
<pre>
  tar xfz DBD-Oracle-1.40.tar.gz</pre>
<p>Then create a patch file by performing a recursive <code>diff</code> on the two
top level directories:</p>
<pre>
  diff -r -u DBD-Oracle-1.40 DBD-Oracle-1.40.your_foo &gt; DBD-Oracle-1.40.your_foo.patch</pre>
<p>
</p>
<h2><a name="speak_before_you_patch">Speak before you patch</a></h2>
<p>For anything non-trivial or possibly controversial it's a good idea
to discuss (on <a href="mailto:dbi-dev@perl.org)">dbi-dev@perl.org)</a> the changes you propose before
actually spending time working on them. Otherwise you run the risk
of them being rejected because they don't fit into some larger plans
you may not be aware of.</p>

</body>

</html>
